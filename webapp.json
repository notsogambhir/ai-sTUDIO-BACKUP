{
  "index.tsx": "/**\n * @file index.tsx\n * @description\n * This is the very first file that runs for our React application.\n * Think of it as the \"ignition switch\" that starts the engine.\n *\n * Its main jobs are:\n * 1.  Importing the necessary starter tools from React.\n * 2.  Importing our main `App` component and the `AppProvider` (our magic backpack).\n * 3.  Finding the one special `<div>` in `index.html` with the ID \"root\".\n * 4.  Telling React to render our entire application inside that `<div>`.\n * 5.  Setting up extra tools, like the library for drawing charts (`Chart.js`).\n */\n\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { AppProvider } from './context/AppContext'; // Imports the \"magic backpack\" provider.\nimport App from './App'; // Imports the main \"brain\" of our app.\nimport { Chart as ChartJS, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend } from 'chart.js';\n\n// This section is for setting up the Chart.js library, which we use to draw graphs.\n// It's like telling the app, \"Hey, if you need to draw a bar chart, you'll need these tools:\n// an X-axis (CategoryScale), a Y-axis (LinearScale), the bars themselves (BarElement), etc.\"\nChartJS.register(CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);\n\n// This line looks for the HTML element in `index.html` that has the ID 'root'.\n// This is the container where our entire app will live.\nconst rootElement = document.getElementById('root');\nif (!rootElement) {\n  // A safety check. If it can't find the 'root' container, it stops and shows an error.\n  throw new Error(\"Could not find root element to mount to\");\n}\n\n// This creates the main \"root\" for our React application, using the container we just found.\nconst root = ReactDOM.createRoot(rootElement);\n\n// This is the final and most important step: `root.render()`.\n// It tells React, \"Take our App, put it inside the AppProvider, and render it all on the screen.\"\n// - `<React.StrictMode>` is a helper that checks for potential problems in the app.\n// - `<AppProvider>` is our \"magic backpack\" component. It wraps around the entire `App` so that\n//   every component inside the app can access the shared data.\n// - `<App />` is the main component of our application.\nroot.render(\n  <React.StrictMode>\n    <AppProvider>\n      <App />\n    </AppProvider>\n  </React.StrictMode>\n);",
  "metadata.json": "{\n  \"name\": \"NBA Outcome Based Education Portal\",\n  \"description\": \"A comprehensive application for managing and calculating Course Outcome (CO) and Program Outcome (PO) attainment based on National Board of Accreditation (NBA) guidelines for Outcome Based Education (OBE).\",\n  \"requestFramePermissions\": []\n}",
  "pages/index.html": "<!--\n  @file index.html\n  @description\n  This is the very first file the web browser opens when someone visits our website.\n  Think of it as the blueprint for a house before we start building. It sets up the\n  basic structure and tells the browser what tools and materials (like styles and scripts)\n  it needs to build our beautiful application.\n-->\n<!DOCTYPE html>\n<!-- This line says, \"Hey browser, I'm a modern webpage using the latest HTML rules (HTML5).\" -->\n<html lang=\"en\" class=\"h-full\">\n  <!-- The <head> is like the \"brain\" or \"control room\" of the page.\n       It contains all the important information that you don't see on the screen,\n       but it tells the browser how to work, what the page is called, and where to find its tools. -->\n  <head>\n    <meta charset=\"UTF-8\" />\n    \n    <!-- This is the little picture (like a tiny logo) that you see in the browser tab. -->\n    <link rel=\"icon\" type=\"image/png\" href=\"https://d1hbpr09pwz0sk.cloudfront.net/logo_url/chitkara-university-4c35e411\" />\n    \n    <!-- This is a special instruction for mobile phones. It tells them, \"Make the page fit\n         the width of your screen, and don't try to zoom out.\" This makes the app look good on phones. -->\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    \n    <!-- This is the text that appears as the title in the browser tab. -->\n    <title>NBA OBE Portal</title>\n    \n    <!-- SCRIPT TOOLBOXES -->\n    <!-- These lines are like telling the browser, \"Before you do anything else, go to these\n         internet addresses and grab these toolboxes for me. I'll need them later.\" -->\n\n    <!-- 1. TailwindCSS: This is our giant box of digital crayons, stickers, and building blocks for styling.\n         It gives us all the easy-to-use classes (like \"bg-blue-500\" for a blue background) that let us\n         make our app look nice without writing a lot of custom CSS code. -->\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n    \n    <!-- 2. SheetJS (xlsx): This is our \"Excel expert\" toolbox. It's a special library that\n         knows how to read and understand Microsoft Excel files (.xlsx). We use this for all the\n         \"Upload Excel\" buttons in our app. -->\n    <script src=\"https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js\"></script>\n    \n    <!-- 3. PDF Generation Libraries: These two toolboxes work together like a photographer and a printer.\n         - html2canvas: This is the \"photographer\". It knows how to take a perfect, high-quality\n           \"screenshot\" of a part of our webpage.\n         - jsPDF: This is the \"printer\". It takes the screenshot from html2canvas and turns it into\n           a beautiful, multi-page PDF file that the user can download.\n         The 'defer' attribute is a special instruction that says: \"You can download these toolboxes\n         now, but please wait until the rest of the page is fully built before you open them.\"\n         This is very important because it prevents errors where our app might try to use a tool\n         before it's ready. -->\n    <script defer src=\"https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js\"></script>\n    <script defer src=\"https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js\"></script>\n    \n    <!-- This is our app's \"address book\" or \"map\". It tells the browser that whenever our\n         main code (`index.tsx`) asks for a big, important tool like \"react\" or \"react-router-dom\",\n         it should go to these specific internet addresses to find them. This is how our app\n         gets the core React library that makes everything work. -->\n  <script type=\"importmap\">\n{\n  \"imports\": {\n    \"react\": \"https://aistudiocdn.com/react@^19.1.1\",\n    \"react-dom/\": \"https://aistudiocdn.com/react-dom@^19.1.1/\",\n    \"react/\": \"https://aistudiocdn.com/react@^19.1.1/\",\n    \"chart.js\": \"https://cdn.jsdelivr.net/npm/chart.js@4.4.2/+esm\",\n    \"react-chartjs-2\": \"https://cdn.jsdelivr.net/npm/react-chartjs-2@5.2.0/+esm\",\n    \"react-router-dom\": \"https://aistudiocdn.com/react-router-dom@^7.9.2\"\n  }\n}\n</script>\n\n<!-- PRINT-ONLY STYLES -->\n<!-- This is a special set of rules that only apply when the user tries to print the page (or save as PDF).\n     It's like a magic costume the page puts on just before it goes to the printer. Its main job is to\n     make the final paper copy look clean and professional by hiding everything that shouldn't be on it,\n     like buttons, sidebars, and headers, so that only the report itself is visible. -->\n<style type=\"text/css\" media=\"print\">\n    /* Rule 1: When printing, make everything on the page invisible by default. */\n    body * {\n        visibility: hidden;\n    }\n    /* Rule 2: But, find the special area we marked as 'printable-area' and make IT and everything\n       inside it visible again. This is how we select only the report. */\n    .printable-area, .printable-area * {\n        visibility: visible;\n    }\n    /* Rule 3: Make sure our printable area is positioned perfectly at the top-left corner of the paper. */\n    .printable-area {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n    }\n    /* Rule 4: A helper rule to hide any specific little things inside the report that we still\n       don't want to print, like a \"Print\" button. */\n    .print\\:hidden {\n        display: none !important;\n    }\n</style>\n\n</head>\n  <!-- The <body> is the main visible part of the house. Everything you can see on the screen—all\n       the furniture, windows, and doors—lives inside here. -->\n  <body class=\"h-full bg-gray-100 text-gray-800\" style=\"transform: scale(0.75); transform-origin: top left; width: 133.33vw; height: 133.33vh;\">\n    <!-- THIS IS THE MOST IMPORTANT DIV ON THE WHOLE PAGE!\n         Think of this `div` with the id \"root\" as the main stage in a theater. Our entire React application,\n         with all its components, pages, and buttons, will be built and \"performed\" on this stage.\n         The `index.tsx` file (our director) looks for this specific stage by its ID to know where to start the show. -->\n    <div id=\"root\" class=\"h-full\"></div>\n    \n    <!-- This is the final step. It's like the director shouting \"Action!\".\n         This script tag tells the browser to go and run our main application code, which lives in `index.tsx`.\n         This one line kicks off the entire React app and brings our beautiful page to life. -->\n    <script type=\"module\" src=\"/index.tsx\"></script>\n  </body>\n</html>",
  "App.tsx": "/**\n * @file App.tsx\n * @description\n * This is the main \"brain\" or \"traffic controller\" of the entire application.\n * It's the highest-level component that decides which page or layout to show the user.\n * \n * It uses a tool called React Router (`HashRouter`) to act like a GPS for the app.\n * Based on the URL in the browser's address bar and whether the user is logged in,\n * it directs the user to the correct screen.\n * \n * Main responsibilities:\n * 1.  Manages the primary routing logic (e.g., `/login`, `/dashboard`).\n * 2.  Acts as a gatekeeper: It shows the `LoginScreen` if the user is not logged in.\n * 3.  If the user is logged in, it passes control to the `ProtectedRoutes` component,\n *     which handles all the screens for authenticated users.\n */\n\nimport React from 'react';\nimport { HashRouter, Routes, Route, Navigate, useLocation } from 'react-router-dom';\nimport { useAppContext } from './hooks/useAppContext'; // Helper to get shared data like the current user.\n\n// Importing all the different \"pages\" or \"screens\" of the application.\n// Think of these as the different destinations our app's GPS can navigate to.\nimport LoginScreen from './pages/LoginScreen';\nimport ProgramSelectionScreen from './pages/ProgramSelectionScreen';\nimport MainLayout from './components/MainLayout'; // The main visual structure (Sidebar + Header).\nimport Dashboard from './pages/Dashboard';\nimport CoursesList from './pages/CoursesList';\nimport CourseDetail from './pages/CourseDetail';\nimport ProgramOutcomesList from './pages/ProgramOutcomesList';\nimport StudentCOAttainmentReport from './pages/StudentCOAttainmentReport';\nimport AttainmentReports from './pages/AttainmentReports';\nimport StudentsList from './pages/StudentsList';\nimport TeacherManagement from './pages/TeacherManagement';\nimport TeacherDetails from './pages/TeacherDetails';\nimport DepartmentStudentManagement from './pages/DepartmentStudentManagement';\nimport DepartmentFacultyManagement from './pages/DepartmentFacultyManagement';\nimport AdminPanel from './pages/AdminPanel';\n\n/**\n * A special component that handles all the routing for a user who is already logged in.\n * It acts as a security guard and a smart navigator inside the main app.\n */\nconst ProtectedRoutes: React.FC = () => {\n    // We ask our \"magic backpack\" (AppContext) for the current user and their selections.\n    const { currentUser, selectedProgram, selectedBatch } = useAppContext();\n    const location = useLocation(); // This tells us the user's current URL.\n\n    // If for some reason there's no user, send them back to the login page immediately.\n    if (!currentUser) {\n        return <Navigate to=\"/login\" state={{ from: location }} replace />;\n    }\n\n    // These users have dropdowns in their sidebar to choose programs, so they don't need the full-page selection screen.\n    const rolesWithSidebarSelectors = ['Admin', 'University', 'Department'];\n    // Check if the user needs to pick a program and batch to continue.\n    const needsProgramSelection = !selectedProgram || !selectedBatch;\n\n    // If a user (like a Teacher or PC) needs to select a program but hasn't yet,\n    // we stop them and show them the ProgramSelectionScreen.\n    if (needsProgramSelection && !rolesWithSidebarSelectors.includes(currentUser.role)) {\n        return <ProgramSelectionScreen />;\n    }\n    \n    // If the user is logged in and has made their selections (or doesn't need to),\n    // we show them the main application layout with all the possible pages inside.\n    return (\n        // `MainLayout` provides the consistent Sidebar and Header for all pages.\n        <MainLayout>\n            {/* The `Routes` component looks at the URL and decides which page `element` to show. */}\n            <Routes>\n                {/* Admin-specific pages */}\n                <Route path=\"/admin/academic-structure\" element={<AdminPanel view=\"Academic Structure\" />} />\n                <Route path=\"/admin/user-management\" element={<AdminPanel view=\"User Management\" />} />\n                <Route path=\"/admin/system-settings\" element={<AdminPanel view=\"System Settings\" />} />\n                \n                {/* Department-specific pages */}\n                <Route path=\"/department/students\" element={<DepartmentStudentManagement />} />\n                <Route path=\"/department/faculty\" element={<DepartmentFacultyManagement />} />\n\n                {/* Standard pages accessible by multiple roles (Teacher, PC, Admin, Department, etc.) */}\n                <Route path=\"/dashboard\" element={<Dashboard />} />\n                <Route path=\"/courses\" element={<CoursesList />} />\n                {/* The \":courseId\" part is a placeholder for the actual ID of a course. */}\n                <Route path=\"/courses/:courseId\" element={<CourseDetail />} />\n                <Route path=\"/courses/:courseId/report\" element={<StudentCOAttainmentReport />} />\n                <Route path=\"/program-outcomes\" element={<ProgramOutcomesList />} />\n                <Route path=\"/students\" element={<StudentsList />} />\n                <Route path=\"/teachers\" element={<TeacherManagement />} />\n                <Route path=\"/teachers/:teacherId\" element={<TeacherDetails />} />\n                <Route path=\"/reports\" element={<AttainmentReports />} />\n                <Route path=\"/program-selection\" element={<ProgramSelectionScreen />} />\n                \n                {/* This is the default \"catch-all\" route. If the URL doesn't match anything above,\n                    it will redirect the user to a default page based on their role. */}\n                <Route path=\"*\" element={<Navigate to={\n                    // A Department user's default page is different from others.\n                    currentUser.role === 'Department' ? \"/department/faculty\" : \"/dashboard\"\n                } replace />} />\n            </Routes>\n        </MainLayout>\n    );\n};\n\n\n/**\n * The main App component. This is the root of our entire application's UI.\n */\nconst App: React.FC = () => {\n  // Get the current user from our shared data \"backpack\".\n  const { currentUser } = useAppContext();\n\n  return (\n    // `HashRouter` is the component that enables all the routing functionality (the app's GPS).\n    <HashRouter>\n        {/* `Routes` decides which of the top-level routes to render. */}\n        <Routes>\n            {/* If the URL is `/login`, show the LoginScreen. */}\n            <Route path=\"/login\" element={<LoginScreen />} />\n            {/* For any other URL (`/*`), check if a user is logged in.\n                If yes, render the `ProtectedRoutes` component which contains the main app.\n                If no, redirect them back to the `/login` page. */}\n            <Route path=\"/*\" element={currentUser ? <ProtectedRoutes /> : <Navigate to=\"/login\" />} />\n        </Routes>\n    </HashRouter>\n  );\n};\n\nexport default App;",
  "types.ts": "/**\n * @file types.ts\n * @description\n * This file is like a dictionary or a rulebook for all the data in our application.\n * It defines the \"shape\" of every piece of data we use, like what a 'User' should\n * look like, or what information a 'Course' must have.\n *\n * Think of an \"interface\" as a blueprint for an object. If we're building a car,\n * the blueprint says it MUST have 4 wheels, an engine, and doors. Our `User` interface\n * says a user object MUST have an `id`, a `name`, and a `role`. This helps us avoid\n * bugs by ensuring our data is always structured correctly everywhere in the app.\n */\n\n\n// --- Enums and Basic Types ---\n// These are simple lists of allowed values for certain properties.\n// It's like saying a traffic light can only be 'Red', 'Yellow', or 'Green'.\n\n// The different roles a user can have in the system.\nexport type Role = 'Teacher' | 'Program Co-ordinator' | 'University' | 'Admin' | 'Department';\n\n// The different colleges available in the university.\nexport type College = 'CUIET' | 'CCP' | 'CBS';\n\n// The possible statuses for a course.\nexport type CourseStatus = 'Active' | 'Completed' | 'Future';\n\n// The possible statuses for a student.\nexport type StudentStatus = 'Active' | 'Inactive';\n\n\n// --- System-wide Settings ---\n// This is the blueprint for the application's overall default settings,\n// which can be configured by an Admin. It's like the main settings menu on a phone.\nexport interface SystemSettings {\n  // The default percentage a student needs to achieve on a Course Outcome.\n  defaultCoTarget: number;\n  // The default thresholds for calculating CO attainment levels.\n  // This is the grading rule for how well the class is doing as a whole.\n  defaultAttainmentLevels: {\n    level3: number; // e.g., 80% of students must meet the target for Level 3\n    level2: number; // e.g., 70% of students must meet the target for Level 2\n    level1: number; // e.g., 50% of students must meet the target for Level 1\n  };\n  // The default weights for combining direct and indirect PO attainment.\n  defaultWeights: {\n    direct: number; // The part of the score from student tests.\n    indirect: number; // The part of the score from surveys or other feedback.\n  };\n}\n\n\n// --- Data Structures ---\n// These interfaces are the blueprints for the main \"objects\" in our application.\n\n// Blueprint for a User account.\nexport interface User {\n  id: string; // A unique identifier for the user.\n  employeeId: string; // The user's official employee ID.\n  username: string; // The username they use to log in.\n  password?: string; // The user's password (optional because we don't always send it from the database).\n  role: Role; // The user's job title (e.g., 'Teacher').\n  name: string; // The user's full name.\n  programId?: string; // If the user is a PC, this is the ID of the program they manage.\n  programCoordinatorIds?: string[]; // If a Teacher, these are the PCs they report to.\n  status?: 'Active' | 'Inactive'; // Whether the user account is active.\n  collegeId?: College; // If the user is a Department head, this is the college they manage.\n  departmentId?: string; // If the user is a PC, this is the Department head they report to.\n}\n\n// Blueprint for an academic Program (e.g., \"BE ECE\").\nexport interface Program {\n  id: string; // A unique identifier for the program.\n  name: string; // The full name of the program.\n  collegeId: College; // The college this program belongs to.\n  duration: number; // The duration of the program in years.\n}\n\n// Blueprint for a Batch of students (e.g., the \"2025-2029\" batch).\nexport interface Batch {\n  id: string; // A unique identifier for the batch.\n  programId: string; // The program this batch belongs to.\n  name: string; // The name of the batch, like \"2025-2029\".\n}\n\n// Blueprint for a Course (e.g., \"Introduction to Programming\").\nexport interface Course {\n  id: string; // A unique identifier for the course.\n  name: string; // The full name of the course.\n  code: string; // The course code (e.g., \"CS101\").\n  programId: string; // The program this course belongs to.\n  target: number; // The target attainment percentage for this course's COs.\n  internalWeightage: number; // Weightage of internal assessments (e.g., mid-terms).\n  externalWeightage: number; // Weightage of external assessments (e.g., final exams).\n  attainmentLevels: { // Thresholds for calculating CO attainment levels for this specific course.\n    level3: number;\n    level2: number;\n    level1: number;\n  };\n  status: CourseStatus; // The current status of the course.\n  teacherId?: string | null; // The default teacher assigned to the whole course.\n  sectionTeacherIds?: { [sectionId: string]: string }; // Specific teacher assignments for each section.\n}\n\n// Blueprint for a Student.\nexport interface Student {\n  id: string; // The student's unique ID or registration number.\n  name: string; // The student's full name.\n  programId: string; // The program the student is enrolled in.\n  status: StudentStatus; // The student's current status.\n  sectionId?: string | null; // The section the student belongs to (e.g., \"Section A\").\n}\n\n// Blueprint for an Enrollment record, which is like a ticket that links one student to one course.\nexport interface Enrollment {\n  courseId: string;\n  studentId: string;\n  sectionId?: string | null; // The specific section the student is enrolled in for this course.\n}\n\n// Blueprint for a Section (a class group within a batch, e.g., \"Section A\").\nexport interface Section {\n  id: string; // A unique identifier for the section.\n  name: string; // The name of the section (e.g., \"A\").\n  programId: string; // The program this section belongs to.\n  batchId: string; // The batch this section is a part of.\n}\n\n// Blueprint for a Course Outcome (CO) - a specific skill students should learn in a course.\nexport interface CourseOutcome {\n  id: string; // A unique identifier for the CO.\n  courseId: string; // The course this CO belongs to.\n  number: string; // The CO number (e.g., \"CO1\").\n  description: string; // The description of the outcome (e.g., \"Can write a basic program\").\n}\n\n// Blueprint for a Program Outcome (PO) - a broad skill graduates should have after the whole program.\nexport interface ProgramOutcome {\n  id: string; // A unique identifier for the PO.\n  number: string; // The PO number (e.g., \"PO1\").\n  description: string; // The description of the outcome (e.g., \"Can work effectively in a team\").\n  programId: string; // The program this PO belongs to.\n}\n\n// Blueprint for a mapping between a CO and a PO. It's like a thread connecting a small skill to a big skill.\nexport interface CoPoMapping {\n  courseId: string;\n  coId: string;\n  poId: string;\n  level: number; // The strength of the connection (1=weak, 2=medium, 3=strong).\n}\n\n// Blueprint for a single question within an assessment.\nexport interface AssessmentQuestion {\n  q: string; // The question number (e.g., \"Q1\").\n  coIds: string[]; // A list of the COs that this question tests.\n  maxMarks: number; // The maximum marks for this question.\n}\n\n// Blueprint for an Assessment (e.g., a test or exam).\nexport interface Assessment {\n  id: string; // A unique identifier for the assessment.\n  sectionId: string; // The section this assessment was for.\n  name: string; // The name of the assessment (e.g., \"Mid-Term Exam\").\n  type: 'Internal' | 'External'; // The type of assessment.\n  questions: AssessmentQuestion[]; // The list of questions in the assessment.\n}\n\n// Blueprint for a student's score on a single question.\nexport interface MarkScore {\n  q: string; // The question number.\n  marks: number; // The marks obtained.\n}\n\n// Blueprint for a student's marks in a whole assessment. This is their answer sheet.\nexport interface Mark {\n  studentId: string;\n  assessmentId: string;\n  scores: MarkScore[]; // A list of scores for each question.\n}\n\n// A helper type for the CO-PO mapping matrix, making it easier to look up levels.\n// It's structured like a grid: { \"co_id_1\": { \"po_id_1\": 3, \"po_id_2\": 2 } }\nexport interface CoPoMap {\n  [coId: string]: {\n    [poId: string]: number;\n  };\n}\n\n// A helper type for Excel uploads of student marks.\nexport interface StudentMark {\n  studentId: string;\n  [key: string]: string | number | 'U'; // Allows for dynamic question columns like \"Q1\", \"Q2\", etc. 'U' stands for unanswered/absent.\n}\n\n// This interface brings everything together, defining the shape of our entire \"database\" (`mockData.json`).\n// It's the master blueprint for all the data in the app.\nexport interface AppData {\n  users: User[];\n  colleges: { id: College; name: string }[];\n  programs: Program[];\n  batches: Batch[];\n  courses: Course[];\n  students: Student[];\n  enrollments: Enrollment[];\n  sections: Section[];\n  courseOutcomes: CourseOutcome[];\n  programOutcomes: ProgramOutcome[];\n  coPoMapping: CoPoMapping[];\n  assessments: Assessment[];\n  marks: Mark[];\n  settings: SystemSettings;\n}",
  "context/AppContext.tsx": "/**\n * @file AppContext.tsx\n * @description\n * This file is one of the most important in the application. It creates and manages\n * the \"magic backpack\" for the entire app, which we call a React Context.\n *\n * What is a \"magic backpack\" (Context)?\n * Imagine you have data (like the logged-in user) that many different components\n * need to know about. Instead of passing this data down through every single component\n * (parent to child to grandchild...), we can put it in this global backpack. Any\n * component, no matter how deep it is, can then just reach into the backpack and\n * get the data it needs.\n *\n * This file is responsible for:\n * 1. Creating the context (the backpack itself).\n * 2. Creating a \"Provider\" component that holds all the data and functions and makes them\n *    available to all child components wrapped inside it.\n * 3. Managing all the core \"state\" (memory) of the app, such as:\n *    - The entire application's data (loaded from mockData.json).\n *    - The `currentUser` who is logged in.\n *    - The `selectedProgram` and `selectedBatch`.\n * 4. Providing essential functions that can be used anywhere, like `login()`, `logout()`,\n *    and `setProgramAndBatch()`.\n */\n\nimport React, { createContext, useState, useCallback, useMemo, ReactNode, useEffect } from 'react';\n// Imports the data \"shapes\" from our dictionary (types.ts) to ensure data consistency.\nimport { User, Program, College, AppData } from '../types';\n\n// This defines what the \"magic backpack\" (AppContext) will contain.\n// It's a list of all the data and tools that will be available to other components.\ninterface AppContextType {\n  data: AppData; // All the app's data from mockData.json\n  setData: React.Dispatch<React.SetStateAction<AppData>>; // A tool to update the data\n  currentUser: User | null; // The logged-in user, or null if nobody is logged in\n  selectedLoginCollege: College | null; // The college selected on the login screen\n  selectedProgram: Program | null; // The program the user is currently looking at\n  selectedBatch: string | null; // The batch the user has selected\n  selectedCollegeId: string | null; // The college ID the user is currently viewing\n  setSelectedCollegeId: React.Dispatch<React.SetStateAction<string | null>>; // Tool to change the selected college\n  login: (username: string, password: string, college: College) => boolean; // The login function\n  logout: () => void; // The logout function\n  setProgramAndBatch: (program: Program, batch: string) => void; // Function to select a program/batch\n  goBackToProgramSelection: () => void; // Function to clear program/batch selection\n}\n\n// Here, we create the actual \"backpack\". `createContext` is a function from React.\n// It's initially empty (`undefined`).\nexport const AppContext = createContext<AppContextType | undefined>(undefined);\n\n/**\n * This is the main component that manages all the state and logic. It only renders\n * its children *after* the initial data has been successfully loaded.\n * It receives the loaded data as a prop (`initialData`).\n */\nconst LoadedAppProvider: React.FC<{ children: ReactNode, initialData: AppData }> = ({ children, initialData }) => {\n  // `useState` is a React Hook that gives a component its own memory.\n  // It returns a piece of data and a function to update that data.\n  \n  // Memory for all application data (users, courses, etc.)\n  const [data, setData] = useState<AppData>(initialData);\n  // Memory for the currently logged-in user.\n  const [currentUser, setCurrentUser] = useState<User | null>(null);\n  // Memory for the college chosen at the login screen.\n  const [selectedLoginCollege, setSelectedLoginCollege] = useState<College | null>(null);\n  // Memory for the program selected by the user.\n  const [selectedProgram, setSelectedProgram] = useState<Program | null>(null);\n  // Memory for the batch selected by the user.\n  const [selectedBatch, setSelectedBatch] = useState<string | null>(null);\n  // Memory for the college selected in the sidebar (for Admin/University users).\n  const [selectedCollegeId, setSelectedCollegeId] = useState<string | null>(null);\n\n  /**\n   * The login function. It checks if a user with the given credentials exists.\n   * `useCallback` is an optimization that prevents this function from being recreated on every render.\n   */\n  const login = useCallback((username: string, password: string, college: College) => {\n    // Find a user in our data that matches the provided username and password.\n    const user = data.users.find(\n      (u) =>\n        u.username.toLowerCase() === username.toLowerCase() &&\n        u.password === password\n    );\n    \n    // If we found a matching user...\n    if (user) {\n      setCurrentUser(user); // Remember this user as the one who is logged in.\n      setSelectedLoginCollege(college); // Remember the college they logged in with.\n\n      // For Department users, we immediately set their selected college in the sidebar\n      // so they can start working right away.\n      if (user.role === 'Department' && user.collegeId) {\n        setSelectedCollegeId(user.collegeId);\n      }\n\n      // If the user is not a high-level one, clear any previous program selection\n      // to force them to pick a new one.\n      if (user.role !== 'Admin' && user.role !== 'University' && user.role !== 'Department') {\n        setSelectedProgram(null);\n        setSelectedBatch(null);\n      }\n      return true; // Indicate that login was successful.\n    }\n    return false; // Indicate that login failed.\n  }, [data.users]);\n\n  /**\n   * The logout function. It clears all user-specific data from memory.\n   */\n  const logout = useCallback(() => {\n    setCurrentUser(null);\n    setSelectedLoginCollege(null);\n    setSelectedProgram(null);\n    setSelectedBatch(null);\n    setSelectedCollegeId(null);\n  }, []);\n\n  /**\n   * This function is called when a user selects a program and a batch.\n   */\n  const setProgramAndBatch = useCallback((program: Program, batch: string) => {\n    setSelectedProgram(program); // Remember the selected program.\n    setSelectedBatch(batch); // Remember the selected batch.\n    setSelectedCollegeId(program.collegeId); // Also update the selected college to match the program.\n  }, []);\n\n  /**\n   * This function clears the program/batch selection, usually to send the user\n   * back to the program selection screen.\n   */\n  const goBackToProgramSelection = useCallback(() => {\n    setSelectedProgram(null);\n    setSelectedBatch(null);\n  }, []);\n\n  // `useMemo` is another optimization. It bundles up all the context values and only\n  // rebuilds the bundle if one of the values inside has actually changed.\n  const value = useMemo(\n    () => ({\n      data,\n      setData,\n      currentUser,\n      login,\n      logout,\n      selectedLoginCollege,\n      selectedProgram,\n      selectedBatch,\n      setProgramAndBatch,\n      goBackToProgramSelection,\n      selectedCollegeId,\n      setSelectedCollegeId,\n    }),\n    [\n      data,\n      currentUser,\n      login,\n      logout,\n      selectedLoginCollege,\n      selectedProgram,\n      selectedBatch,\n      setProgramAndBatch,\n      goBackToProgramSelection,\n      selectedCollegeId,\n    ]\n  );\n\n  // This is the magic part. The `AppContext.Provider` component makes the `value`\n  // (our bundle of data and functions) available to all `children` components.\n  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n};\n\n\n/**\n * This is the component that gets exported and used in `index.tsx`.\n * Its only job is to load the initial data from the fake database (`mockData.json`)\n * and show a loading screen while it's waiting. Once the data is loaded, it\n * renders the `LoadedAppProvider` with that data.\n */\nexport const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  // A piece of memory to hold the data once it's loaded from the file. Starts as `null`.\n  const [initialData, setInitialData] = useState<AppData | null>(null);\n\n  // `useEffect` is a hook that runs code \"on the side\" after the component renders.\n  // An empty dependency array `[]` means this code runs only once when the component first appears.\n  useEffect(() => {\n    // We use the browser's `fetch` API to load our local JSON file.\n    fetch('./mockData.json')\n      .then(res => res.json()) // Convert the response to JSON format.\n      .then(jsonData => {\n        setInitialData(jsonData); // Store the loaded data in our component's memory.\n      })\n      .catch(error => console.error(\"Failed to load mock data:\", error)); // Handle any errors.\n  }, []);\n\n  // While we're waiting for the data to load (`initialData` is still `null`),\n  // we show a friendly loading screen.\n  if (!initialData) {\n    return (\n      <div className=\"flex items-center justify-center h-screen bg-gray-100\">\n          <div className=\"text-center\">\n              <img src=\"https://d1hbpr09pwz0sk.cloudfront.net/logo_url/chitkara-university-4c35e411\" alt=\"Logo\" className=\"h-20 mx-auto mb-4 animate-pulse\" />\n              <p className=\"text-xl font-semibold text-gray-700\">Loading Portal...</p>\n          </div>\n      </div>\n    );\n  }\n\n  // Once `initialData` has been loaded, we render the main provider and pass the data to it.\n  return <LoadedAppProvider initialData={initialData}>{children}</LoadedAppProvider>;\n};",
  "hooks/useAppContext.ts": "/**\n * @file useAppContext.ts\n * @description\n * This file provides a simple \"shortcut\" or \"helper\" for using our app's shared data.\n *\n * In React, to use a context (our \"magic backpack\"), you typically have to import `useContext`\n * from React and the `AppContext` from our context file. This little helper function,\n * called a \"custom hook\", does both of those things for us in one go.\n *\n * So, instead of writing two import lines in every component that needs the shared data,\n * we can just write one: `import { useAppContext } from './hooks/useAppContext';`.\n *\n * It also includes an error check to make sure that we are only trying to use this\n * context within a component that is a child of the `AppProvider`. If not, it gives\n * a helpful error message.\n */\n\nimport { useContext } from 'react';\nimport { AppContext } from '../context/AppContext'; // Importing our actual \"magic backpack\".\n\n/**\n * A custom hook to easily access the AppContext.\n * @returns The context value (all our shared data and functions).\n */\nexport const useAppContext = () => {\n  // `useContext` is the React tool to look inside the \"magic backpack\".\n  const context = useContext(AppContext);\n\n  // If the component is not inside an `AppProvider`, the context will be `undefined`.\n  // This is a safety check to prevent bugs and guide developers.\n  if (context === undefined) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n\n  // If everything is okay, we return the context.\n  return context;\n};",
  "components/MainLayout.tsx": "/**\n * @file MainLayout.tsx\n * @description\n * This file defines the main visual structure or \"layout\" for almost every page in the application.\n *\n * Think of it as a picture frame:\n * - The frame itself is the `Sidebar` on the left and the `Header` at the top.\n * - The picture inside the frame is the `children`, which represents the actual content of\n *   whatever page the user is currently on (like the Dashboard or the Courses list).\n *\n * By using this component, we ensure that every page has a consistent look and feel\n * without having to repeat the code for the sidebar and header everywhere.\n */\n\nimport React from 'react';\nimport Sidebar from './Sidebar'; // Importing the sidebar component.\nimport Header from './Header'; // Importing the header component.\n\n// This defines the \"props\" or properties that this component accepts.\n// In this case, it accepts `children`, which is a standard React prop that\n// represents any components nested inside this one.\ninterface MainLayoutProps {\n  children: React.ReactNode;\n}\n\n// This is the main component function.\nconst MainLayout: React.FC<MainLayoutProps> = ({ children }) => {\n  // The `return` statement describes what the component looks like using HTML-like JSX.\n  return (\n    // This is the main container for the whole screen, using Flexbox to arrange items.\n    <div className=\"flex h-full bg-gray-100 font-sans\">\n      {/* The Sidebar component is placed on the left. */}\n      <Sidebar />\n      \n      {/* This `main` element will take up the rest of the available space. */}\n      <main className=\"flex-1 flex flex-col overflow-hidden\">\n        {/* The Header component is placed at the top of the main content area. */}\n        <Header />\n        \n        {/* This is where the actual page content (`children`) will be displayed. */}\n        {/* The classes here make it scrollable if the content is too long. */}\n        <div className=\"flex-1 overflow-x-hidden overflow-y-auto p-4 sm:p-6 lg:p-8\">\n            {children}\n        </div>\n      </main>\n    </div>\n  );\n};\n\n// We export the component so it can be used in other files, like `App.tsx`.\nexport default MainLayout;",
  "components/Sidebar.tsx": "/**\n * @file Sidebar.tsx\n * @description\n * This file defines the `Sidebar` component, which is the navigation menu on the\n * left side of the screen. It's a key part of the app's navigation.\n *\n * Responsibilities:\n * 1.  Displays the university logo.\n * 2.  For high-level users (Admin, University, Department), it shows dropdowns to\n *     select a College, Program, and Batch. Changing these dropdowns filters the\n *     data for the entire application.\n * 3.  Displays a list of navigation links (like \"Dashboard\", \"Courses\", \"Students\").\n * 4.  The links shown are based on the logged-in user's role. For example, a \"Teacher\"\n *     will not see the \"User Management\" link.\n * 5.  Highlights the currently active link.\n */\n\nimport React, { useMemo } from 'react';\nimport { NavLink, useNavigate } from 'react-router-dom';\nimport { useAppContext } from '../hooks/useAppContext'; // Helper to get shared data.\n// Importing all the little icon images we need for the menu items.\nimport {\n    PieChart, BookOpen, Users, Target, Settings, Grid\n} from './Icons';\n\n// This is the main component function for the Sidebar.\nconst Sidebar: React.FC = () => {\n  // We ask our \"magic backpack\" (AppContext) for all the data and tools we need.\n  const { \n    currentUser, \n    data, \n    selectedProgram, \n    selectedBatch, \n    setProgramAndBatch, \n    goBackToProgramSelection, \n    selectedCollegeId, \n    setSelectedCollegeId \n  } = useAppContext();\n  \n  // `useNavigate` gives us a function to tell the app to go to a different page.\n  const navigate = useNavigate();\n\n  // A simple check to see if the current user is an Admin, University, or Department user.\n  // These are the roles that get to see the dropdown filters.\n  const isHighLevelUser = currentUser && ['Admin', 'University', 'Department'].includes(currentUser.role);\n  \n  // `useMemo` is a performance helper. It only recalculates this list of programs\n  // when the `selectedCollegeId` changes. This prevents unnecessary work.\n  const programsForSelectedCollege = useMemo(() => {\n    if (!selectedCollegeId) return []; // If no college is selected, the list is empty.\n    // Filter all programs in our data to find the ones that match the selected college.\n    return data.programs.filter(p => p.collegeId === selectedCollegeId);\n  }, [data.programs, selectedCollegeId]);\n\n  // Similarly, this only recalculates the batches when the `selectedProgram` changes.\n  const batchesForProgram = useMemo(() => {\n    if (!selectedProgram) return []; // If no program is selected, the list is empty.\n    // Find all batches that belong to the selected program and sort them.\n    return data.batches\n        .filter(b => b.programId === selectedProgram.id)\n        .sort((a, b) => b.name.localeCompare(a.name)); // Sort by name, newest first.\n  }, [data.batches, selectedProgram]);\n\n  // This function runs when the user changes the College dropdown.\n  const handleCollegeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    const newCollegeId = e.target.value;\n    setSelectedCollegeId(newCollegeId || null); // Update the selected college in our magic backpack.\n    goBackToProgramSelection(); // Clear any previously selected program/batch.\n    navigate('/program-selection'); // Go back to the program selection screen.\n  };\n\n  // This function runs when the user changes the Program dropdown.\n  const handleProgramChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    const newProgramId = e.target.value;\n    if (!newProgramId) {\n        // If they selected \"-- Select Program --\", clear the selection.\n        goBackToProgramSelection();\n        navigate('/program-selection');\n        return;\n    }\n    const program = data.programs.find(p => p.id === newProgramId);\n    if (program) {\n        // Find the available batches for this new program.\n        const programBatches = data.batches.filter(b => b.programId === program.id).sort((a,b) => b.name.localeCompare(a.name));\n        // Automatically select the newest batch as the default.\n        const defaultBatch = programBatches.length > 0 ? programBatches[0].name : '';\n        // Update the program and batch in our magic backpack.\n        setProgramAndBatch(program, defaultBatch);\n    }\n  };\n\n  // This function runs when the user changes the Batch dropdown.\n  const handleBatchChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    if (selectedProgram) {\n        // We only need to update the batch, the program stays the same.\n        setProgramAndBatch(selectedProgram, e.target.value);\n    }\n  };\n\n  // This is a master list of all possible menu items in the sidebar.\n  // Each item has a path (`to`), a label, an icon, and a list of `roles` that can see it.\n  const allMenuItems = [\n    // Department-specific items are listed first to appear at the top for them.\n    { to: '/department/faculty', label: 'Faculty Management', icon: <Users />, roles: ['Department'] },\n    { to: '/department/students', label: 'Student Management', icon: <Users />, roles: ['Department'] },\n    \n    // Standard links for most roles.\n    { to: '/dashboard', label: 'Dashboard', icon: <PieChart />, roles: ['Teacher', 'Program Co-ordinator', 'University', 'Admin', 'Department'] },\n    { to: '/courses', label: 'Courses', icon: <BookOpen />, roles: ['Teacher', 'Program Co-ordinator', 'Admin', 'Department'] },\n    { to: '/students', label: 'Students', icon: <Users />, roles: ['Teacher', 'Program Co-ordinator', 'Admin', 'Department'] },\n    { to: '/teachers', label: 'Teachers', icon: <Users />, roles: ['Program Co-ordinator', 'Department'] },\n    { to: '/program-outcomes', label: 'Program Outcomes', icon: <Target />, roles: ['Program Co-ordinator', 'Admin', 'Department'] },\n    { to: '/reports', label: 'Attainment Reports', icon: <PieChart />, roles: ['Teacher', 'Program Co-ordinator', 'University', 'Admin', 'Department'] },\n\n    // Links only visible to Admins.\n    { to: '/admin/academic-structure', label: 'Academic Structure', icon: <Grid />, roles: ['Admin'] },\n    { to: '/admin/user-management', label: 'User Management', icon: <Users />, roles: ['Admin'] },\n    { to: '/admin/system-settings', label: 'System Settings', icon: <Settings />, roles: ['Admin'] },\n  ];\n  \n  // We filter the `allMenuItems` list to get only the items the current user is allowed to see.\n  const menuItems = allMenuItems.filter(item => currentUser && item.roles.includes(currentUser.role));\n\n  // The JSX below describes what the Sidebar looks like.\n  return (\n    <aside className=\"w-64 bg-white shadow-md flex flex-col hidden sm:flex h-full\">\n        {/* The top part with the university logo */}\n        <div className=\"flex items-center justify-center p-6 border-b flex-shrink-0\">\n           <img src=\"https://d1hbpr09pwz0sk.cloudfront.net/logo_url/chitkara-university-4c35e411\" alt=\"Chitkara University Logo\" className=\"h-10\" />\n        </div>\n\n        {/* This block of dropdowns is only shown if the user is a \"high-level user\". */}\n        {isHighLevelUser && (\n            <div className=\"p-4 space-y-4 border-b flex-shrink-0\">\n                <div>\n                    <label htmlFor=\"college-select\" className=\"block text-sm font-medium text-gray-700\">College</label>\n                    <select id=\"college-select\" value={selectedCollegeId || ''} onChange={handleCollegeChange} disabled={currentUser?.role === 'Department'} className=\"mt-1 block w-full pl-3 pr-10 py-2 text-base bg-white text-gray-900 border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md disabled:bg-gray-100 disabled:cursor-not-allowed\">\n                        <option value=\"\">-- Select College --</option>\n                        {data.colleges.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}\n                    </select>\n                </div>\n                <div>\n                    <label htmlFor=\"program-select\" className=\"block text-sm font-medium text-gray-700\">Program</label>\n                    <select id=\"program-select\" value={selectedProgram?.id || ''} onChange={handleProgramChange} disabled={!selectedCollegeId} className=\"mt-1 block w-full pl-3 pr-10 py-2 text-base bg-white text-gray-900 border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md disabled:bg-gray-100\">\n                        <option value=\"\">-- Select Program --</option>\n                        {programsForSelectedCollege.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}\n                    </select>\n                </div>\n                <div>\n                    <label htmlFor=\"batch-select\" className=\"block text-sm font-medium text-gray-700\">Batch</label>\n                    <select id=\"batch-select\" value={selectedBatch || ''} onChange={handleBatchChange} disabled={!selectedProgram} className=\"mt-1 block w-full pl-3 pr-10 py-2 text-base bg-white text-gray-900 border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md disabled:bg-gray-100\">\n                        <option value=\"\">-- Select Batch --</option>\n                        {batchesForProgram.map(batch => <option key={batch.id} value={batch.name}>{batch.name}</option>)}\n                    </select>\n                </div>\n            </div>\n        )}\n\n      {/* The main navigation area. It scrolls if there are too many items. */}\n      <nav className=\"flex-1 px-4 py-6 overflow-y-auto\">\n        {/* We loop through the `menuItems` and create a `NavLink` for each one. */}\n        {menuItems.map(item => (\n          // `NavLink` is a special type of link from React Router that knows if it's \"active\".\n          <NavLink\n            key={item.to} // A unique key for each item in the list.\n            to={item.to} // The URL this link will navigate to.\n            // This function changes the link's style if it's the active page.\n            className={({ isActive }) =>\n              `w-full flex items-center px-4 py-3 my-1 rounded-lg transition-colors duration-200 ${\n                isActive \n                ? 'bg-blue-500 text-white shadow-lg' // Style for the active link\n                : 'text-gray-600 hover:bg-gray-100' // Style for inactive links\n            }`}\n          >\n            {item.icon} {/* The icon for the menu item */}\n            <span className=\"ml-4 font-medium\">{item.label}</span> {/* The text label */}\n          </NavLink>\n        ))}\n      </nav>\n    </aside>\n  );\n};\n\nexport default Sidebar;",
  "components/Header.tsx": "/**\n * @file Header.tsx\n * @description\n * This file defines the `Header` component, which is the top bar displayed on every page\n * inside the main application layout.\n *\n * It's like the dashboard of a car: it shows important information at a glance.\n *\n * Responsibilities:\n * 1.  Displays the name of the selected program and batch.\n * 2.  Shows the name, role, and ID of the currently logged-in user.\n * 3.  Provides a \"Program Selection\" button to go back to the program grid.\n * 4.  Provides the \"Logout\" button to end the user's session.\n */\n\nimport React from 'react';\nimport { useNavigate } from 'react-router-dom'; // A tool for programmatically changing the page.\nimport { useAppContext } from '../hooks/useAppContext'; // Helper to get shared data.\nimport { LogOut, Grid } from './Icons'; // Imports the logout and grid icon images.\n\nconst Header: React.FC = () => {\n    // We ask our \"magic backpack\" (AppContext) for all the information and tools we need.\n    const { currentUser, selectedProgram, selectedBatch, logout, goBackToProgramSelection } = useAppContext();\n    \n    // `useNavigate` gives us a function (`navigate`) to tell the app to go to a different URL.\n    const navigate = useNavigate();\n\n    /**\n     * This function is called when the user clicks the logout button.\n     */\n    const handleLogout = () => {\n        logout(); // Call the logout function from our \"magic backpack\".\n        navigate('/login'); // Tell the app's GPS to go to the login screen.\n    };\n\n    /**\n     * This function is called when the user clicks the grid icon to go back\n     * to the program selection screen.\n     */\n    const handleGoToSelection = () => {\n        goBackToProgramSelection(); // Call the function from the backpack to clear the selected program.\n        navigate('/program-selection'); // Go to the program selection page.\n    };\n\n    // The JSX below describes what the Header looks like using HTML-like tags.\n    return (\n        <header className=\"bg-white shadow-sm p-4 border-b border-gray-200\">\n            <div className=\"flex items-center justify-between\">\n                {/* Left side of the header */}\n                <div>\n                    {/* Display the selected program's name, or the user's name if no program is selected. */}\n                    <h1 className=\"text-2xl font-bold text-gray-800\">{selectedProgram?.name || currentUser?.name}</h1>\n                    {/* Display the selected batch, or the user's role as a fallback. */}\n                    <p className=\"mt-1 text-gray-500\">\n                        {selectedBatch ? `Batch ${selectedBatch}` : (currentUser?.role || 'User')}\n                    </p>\n                </div>\n                 {/* Right side of the header */}\n                 <div className=\"flex items-center gap-4\">\n                    {/* User's information block */}\n                    <div className=\"text-right\">\n                        <p className=\"font-semibold text-gray-700\">{currentUser?.name}</p>\n                        <p className=\"text-sm text-gray-500\">{currentUser?.role}</p>\n                        <p className=\"text-xs text-gray-400\">{currentUser?.employeeId}</p>\n                    </div>\n                    {/* Program Selection Button */}\n                    <button \n                        onClick={handleGoToSelection}\n                        title=\"Program Selection\"\n                        aria-label=\"Program Selection\"\n                        className=\"p-2 rounded-full hover:bg-gray-100 text-gray-600 transition-colors\"\n                    >\n                        <Grid className=\"w-6 h-6\" />\n                    </button>\n                    {/* Logout Button */}\n                    <button \n                        onClick={handleLogout} \n                        title=\"Logout\"\n                        aria-label=\"Logout\"\n                        className=\"p-2 rounded-full hover:bg-red-100 text-gray-600 hover:text-red-600 transition-colors\"\n                    >\n                        <LogOut className=\"w-6 h-6\" />\n                    </button>\n                </div>\n            </div>\n        </header>\n    );\n};\n\nexport default Header;",
  "components/ExcelUploader.tsx": "/**\n * @file ExcelUploader.tsx\n * @description\n * This file defines a reusable `ExcelUploader` component. It's a button that, when clicked,\n * opens a file selection window for the user to upload an Excel file.\n *\n * It handles the complex process of:\n * 1.  Hiding the ugly default file input and showing a nice button instead.\n * 2.  Reading the contents of the selected file.\n * 3.  Using an external library (`SheetJS/XLSX`) to parse the Excel data into a\n *     format (JSON) that our application can easily use.\n * 4.  Passing this parsed data back up to the parent component that used it.\n *\n * It's made \"generic\" with `<T>`, which means it can be told what \"shape\" of data\n * to expect from the Excel file, making it very flexible and safe to use.\n */\n\nimport React, { useRef, useCallback } from 'react';\nimport { Upload } from './Icons'; // Imports the upload icon image.\n\n// This line tells our code that a library called `XLSX` will be available globally.\n// This library is loaded from a `<script>` tag in `index.html`.\ndeclare const XLSX: any;\n\n// This defines the \"props\" or properties that the component accepts.\n// The `<T>` makes it generic. `T` is a placeholder for a specific data type,\n// like `{ code: string; name: string }`.\ninterface ExcelUploaderProps<T> {\n    onFileUpload: (data: T[]) => void; // A function to call with the parsed data.\n    label: string; // The text to display on the button (e.g., \"Upload Excel\").\n    format: string; // A small help text to show below the button (e.g., \"cols: code, name\").\n}\n\n// This is the main component function.\nfunction ExcelUploader<T>({ onFileUpload, label, format }: ExcelUploaderProps<T>) {\n    // `useRef` is like creating a direct connection to an HTML element.\n    // Here, we're creating a reference to the hidden file input element.\n    const inputRef = useRef<HTMLInputElement>(null);\n\n    // This function runs when the user selects a file.\n    // `useCallback` is an optimization that prevents this function from being recreated\n    // unless its dependencies (like `onFileUpload`) change.\n    const handleFileChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n        // Get the first file from the list of selected files.\n        const file = e.target.files?.[0];\n        if (!file) return; // If no file was selected, do nothing.\n\n        // `FileReader` is a built-in browser tool for reading files.\n        const reader = new FileReader();\n\n        // This function is called when the FileReader has finished reading the file.\n        reader.onload = (event) => {\n            try {\n                // A safety check to make sure the `XLSX` library has loaded.\n                if(typeof XLSX === 'undefined') {\n                    alert('Excel library (SheetJS) is not loaded. Please check your internet connection or script tag.');\n                    return;\n                }\n                // The file data is read as an \"ArrayBuffer\". We convert it into a format\n                // that the XLSX library can understand.\n                const data = new Uint8Array(event.target?.result as ArrayBuffer);\n                // The XLSX library reads the raw data and creates a \"workbook\" object.\n                const workbook = XLSX.read(data, { type: 'array' });\n                // We get the name of the first sheet in the Excel file.\n                const sheetName = workbook.SheetNames[0];\n                // We get the actual worksheet object.\n                const worksheet = workbook.Sheets[sheetName];\n                // The library converts the worksheet into JSON (an array of objects).\n                const json = XLSX.utils.sheet_to_json(worksheet);\n                \n                // We call the `onFileUpload` function provided by the parent component,\n                // passing it the parsed JSON data. We tell TypeScript to trust that this\n                // data has the shape of `<T>`.\n                onFileUpload(json as T[]);\n\n            } catch (error) {\n                // If anything goes wrong during parsing, we show an error.\n                console.error(\"Error parsing Excel file:\", error);\n                alert(\"Failed to parse the Excel file. Please ensure it's a valid format.\");\n            }\n        };\n\n        // Start reading the file.\n        reader.readAsArrayBuffer(file);\n\n        // This is a small trick to allow the user to upload the same file again if they want to.\n        if (inputRef.current) {\n            inputRef.current.value = ''; \n        }\n    }, [onFileUpload]);\n\n    // The JSX below describes what the component looks like.\n    return (\n        <div className=\"flex flex-col items-end\">\n            {/* This is the visible button. When it's clicked, it programmatically \"clicks\"\n                the hidden file input. */}\n            <button\n                type=\"button\"\n                onClick={() => inputRef.current?.click()}\n                className=\"px-4 py-2 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 flex items-center gap-2\"\n            >\n                <Upload className=\"w-5 h-5\" /> {label}\n            </button>\n            {/* This is the actual file input, but it's hidden from the user. */}\n            <input\n                type=\"file\"\n                ref={inputRef} // We connect our `useRef` reference to this element.\n                onChange={handleFileChange} // This function runs when a file is selected.\n                className=\"hidden\"\n                accept=\".xlsx, .xls, .csv\" // Only allow Excel and CSV files.\n            />\n            {/* This shows the small help text below the button. */}\n            {format && <p className=\"text-xs text-gray-500 mt-1\">{format}</p>}\n        </div>\n    );\n};\n\nexport default ExcelUploader;",
  "pages/LoginScreen.tsx": "/**\n * @file LoginScreen.tsx\n * @description\n * This file defines the `LoginScreen` component, which is the first page most users will see.\n *\n * Responsibilities:\n * 1.  Displays the university logo.\n * 2.  Shows a login form with fields for Username, Password, and College.\n * 3.  Handles user input and updates its internal memory (state).\n * 4.  When the user submits the form, it calls the `login` function from our \"magic backpack\"\n *     (AppContext) to check if the credentials are valid.\n * 5.  If login is successful, it navigates the user to the main part of the application.\n * 6.  If login fails, it displays an error message.\n * 7.  Includes a \"developer shortcut\" (double-clicking the logo) to quickly log in with a demo account.\n */\n\nimport React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useAppContext } from '../hooks/useAppContext'; // Helper to get shared data.\nimport { College } from '../types'; // Imports the `College` type from our data dictionary.\n\n// This is the main component function for the Login Screen.\nconst LoginScreen: React.FC = () => {\n    // We ask our \"magic backpack\" (AppContext) for the tools we need.\n    const { login, data, setProgramAndBatch } = useAppContext();\n    \n    // `useNavigate` gives us a function to tell the app to go to a different page.\n    const navigate = useNavigate();\n\n    // `useState` is a React Hook that gives a component its own memory.\n    // Here, we create pieces of memory to store what the user types into the form fields.\n    const [username, setUsername] = useState('');\n    const [password, setPassword] = useState('');\n    // We set the default college to the first one in our data list.\n    const [college, setCollege] = useState<College>(data.colleges[0]?.id || 'CUIET');\n    const [error, setError] = useState(''); // Memory for any error messages to display.\n\n    // This function runs when the user clicks the \"LOGIN\" button.\n    const handleLogin = (e: React.FormEvent) => {\n        e.preventDefault(); // Prevents the browser from reloading the page, which is the default form behavior.\n        setError(''); // Clear any previous error messages.\n        \n        // We call the `login` function from our magic backpack.\n        if (login(username, password, college)) {\n            // If `login` returns true (success), we navigate to the main application page.\n            navigate('/');\n        } else {\n            // If `login` returns false (failure), we set an error message to show the user.\n            setError('Invalid username or password.');\n        }\n    };\n\n    // A secret shortcut for developers to log in quickly without typing.\n    // It runs when the university logo is double-clicked.\n    const handleDeveloperLoginShortcut = () => {\n        const devUser = data.users.find(u => u.username === 'pc_ece');\n        const devProgram = devUser ? data.programs.find(p => p.id === devUser.programId) : undefined;\n\n        if (devUser && devProgram && devUser.password) {\n            if (login(devUser.username, devUser.password, 'CUIET')) {\n                // For this specific shortcut, we also pre-select a program and batch for the user.\n                setProgramAndBatch(devProgram, '2025-2029');\n                navigate('/'); // Navigate to the main app.\n            }\n        } else {\n            console.error(\"Developer shortcut failed: Could not find user 'pc_ece' or their assigned program in mockData.\");\n        }\n    };\n\n    // The JSX below describes what the Login Screen looks like.\n    return (\n        <div className=\"flex flex-col items-center justify-center h-full bg-gray-100\">\n            <div className=\"w-full max-w-md p-8\">\n                {/* The university logo. Double-clicking it triggers the developer shortcut. */}\n                <div className=\"flex justify-center mb-8\" onDoubleClick={handleDeveloperLoginShortcut}>\n                     <img src=\"https://d1hbpr09pwz0sk.cloudfront.net/logo_url/chitkara-university-4c35e411\" alt=\"Logo\" className=\"h-20\" />\n                </div>\n                <div className=\"bg-white p-8 rounded-xl shadow-2xl\">\n                    <h2 className=\"text-3xl font-bold text-center text-red-600 mb-6\">LOG IN</h2>\n                    {/* The `onSubmit` event on the form triggers our `handleLogin` function. */}\n                    <form className=\"space-y-6\" onSubmit={handleLogin}>\n                        <div>\n                            <label htmlFor=\"username\" className=\"text-sm font-bold text-gray-600 tracking-wide\">USERNAME</label>\n                            <input\n                                id=\"username\"\n                                type=\"text\"\n                                required\n                                value={username} // The input's value is tied to our component's memory.\n                                onChange={(e) => setUsername(e.target.value)} // When the user types, we update the memory.\n                                className=\"w-full px-4 py-2 mt-2 text-base text-gray-900 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500\"\n                            />\n                        </div>\n                        <div>\n                            <label htmlFor=\"password-input\" className=\"text-sm font-bold text-gray-600 tracking-wide\">PASSWORD</label>\n                            <input\n                                id=\"password-input\"\n                                type=\"password\"\n                                required\n                                value={password}\n                                onChange={(e) => setPassword(e.target.value)}\n                                className=\"w-full px-4 py-2 mt-2 text-base text-gray-900 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500\"\n                            />\n                        </div>\n                         <div>\n                            <label htmlFor=\"college\" className=\"text-sm font-bold text-gray-600 tracking-wide\">COLLEGE</label>\n                            <select\n                                id=\"college\"\n                                value={college}\n                                onChange={(e) => setCollege(e.target.value as College)}\n                                className=\"w-full px-4 py-2 mt-2 text-base text-gray-900 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500\"\n                            >\n                                {/* We create an <option> for each college in our data. */}\n                                {data.colleges.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}\n                            </select>\n                        </div>\n\n                        {/* If there's an error in our memory, we display it here. */}\n                        {error && <p className=\"text-sm text-center text-red-600\">{error}</p>}\n                        \n                        <div>\n                            <button\n                                type=\"submit\"\n                                className=\"w-full flex justify-center bg-red-600 text-gray-100 p-3 rounded-full tracking-wide font-semibold shadow-lg cursor-pointer transition ease-in duration-300 hover:bg-red-700\"\n                            >\n                                LOGIN\n                            </button>\n                        </div>\n                    </form>\n                    {/* A helpful box showing demo login credentials. */}\n                     <div className=\"p-4 mt-6 text-sm text-gray-600 bg-gray-50 rounded-lg\">\n                      <h4 className=\"font-semibold text-center\">Demo Logins (password: \"password\")</h4>\n                      <ul className=\"mt-2 list-disc list-inside\">\n                        <li>Username: <strong>teacher_ece1</strong> (Teacher)</li>\n                        <li>Username: <strong>pc_ece</strong> (PC)</li>\n                        <li>Username: <strong>dept_cuiet</strong> (Dept, CUIET)</li>\n                        <li>Username: <strong>dept_ccp</strong> (Dept, CCP)</li>\n                        <li>Username: <strong>dept_cbs</strong> (Dept, CBS)</li>\n                        <li>Username: <strong>university</strong></li>\n                        <li>Username: <strong>admin</strong></li>\n                      </ul>\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport default LoginScreen;",
  "pages/ProgramSelectionScreen.tsx": "/**\n * @file ProgramSelectionScreen.tsx\n * @description\n * This file defines the `ProgramSelectionScreen` component. This screen is shown to users\n * (like Teachers and Program Co-ordinators) after they log in but before they can access\n * the main dashboard. It forces them to choose a specific academic program to work with.\n *\n * Responsibilities:\n * 1.  Displays a welcome message with the user's name and role.\n * 2.  Shows a grid of available academic programs.\n * 3.  The list of programs is filtered based on the user's role and the college they\n *     logged in with. (e.g., a PC for \"BE ECE\" will only see that one program).\n * 4.  When a user clicks on a program, it opens a \"modal\" (popup) to ask them to\n *     select a specific batch.\n * 5.  Provides a logout button.\n */\n\nimport React, { useState, useMemo } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useAppContext } from '../hooks/useAppContext'; // Helper to get shared data.\nimport { Program } from '../types'; // Imports the `Program` type from our data dictionary.\nimport BatchSelectionModal from '../components/BatchSelectionModal'; // Imports the batch selection popup.\nimport { GraduationCap, LogOut } from '../components/Icons'; // Imports icon images.\n\n// This is the main component function for the Program Selection screen.\nconst ProgramSelectionScreen: React.FC = () => {\n    // We ask our \"magic backpack\" (AppContext) for the data and tools we need.\n    const { data, currentUser, selectedLoginCollege, logout } = useAppContext();\n    \n    // `useNavigate` gives us a function to tell the app to go to a different page.\n    const navigate = useNavigate();\n    \n    // `useState` gives the component its own memory.\n    // `isModalOpen` remembers whether the batch selection popup should be visible or not.\n    const [isModalOpen, setIsModalOpen] = useState(false);\n    // `selectedProgramForBatch` remembers which program the user just clicked on.\n    const [selectedProgramForBatch, setSelectedProgramForBatch] = useState<Program | null>(null);\n\n    // `useMemo` is a performance helper. It only recalculates this list of programs\n    // when the data or current user changes.\n    const programs = useMemo(() => {\n        if (!currentUser) return []; // If there's no user, show no programs.\n\n        // Admins and University users can see all programs.\n        if (currentUser.role === 'Admin' || currentUser.role === 'University') {\n            return data.programs;\n        }\n        // A Program Co-ordinator can only see the one program they are assigned to.\n        if (currentUser.role === 'Program Co-ordinator') {\n            if (currentUser.programId) {\n                return data.programs.filter(p => p.id === currentUser.programId);\n            }\n            return [];\n        }\n        // Other users (like Teachers) see all programs within the college they logged into.\n        return data.programs.filter(p => p.collegeId === selectedLoginCollege);\n    }, [data.programs, currentUser, selectedLoginCollege]);\n    \n    // This function runs when a user clicks on one of the program cards.\n    const handleProgramSelect = (program: Program) => {\n        setSelectedProgramForBatch(program); // Remember which program was clicked.\n        setIsModalOpen(true); // Open the batch selection popup.\n    };\n\n    // This function runs when the user clicks the logout button.\n    const handleLogout = () => {\n        logout(); // Call the logout function from our magic backpack.\n        navigate('/login'); // Go back to the login screen.\n    };\n\n    // Find the full name of the college for display.\n    const collegeName = data.colleges.find(c => c.id === selectedLoginCollege)?.name || 'All Colleges';\n\n    // The JSX below describes what the screen looks like.\n    return (\n        <div className=\"h-full bg-gray-100 p-8 flex flex-col\">\n            <header className=\"flex items-center justify-between mb-8 flex-shrink-0\">\n                <div className=\"flex items-center gap-4\">\n                   <img src=\"https://d1hbpr09pwz0sk.cloudfront.net/logo_url/chitkara-university-4c35e411\" alt=\"Logo\" className=\"h-12\" />\n                    <div>\n                        <h1 className=\"text-3xl font-bold text-gray-800\">Select a Program</h1>\n                        {/* Display a welcome message to the user. */}\n                        {currentUser && <p className=\"text-gray-600\">\n                           Welcome, {currentUser.name} ({currentUser.role}) | College: <strong>{collegeName}</strong>\n                        </p>}\n                    </div>\n                </div>\n                <button \n                    onClick={handleLogout} \n                    className=\"flex items-center px-4 py-2 font-medium text-gray-600 bg-white border border-gray-200 rounded-lg shadow-sm hover:bg-gray-100\"\n                >\n                    <LogOut className=\"w-5 h-5 mr-2\" />\n                    Logout\n                </button>\n            </header>\n            <div className=\"flex-grow overflow-y-auto\">\n                {/* This grid will display all the program cards. */}\n                <div className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6\">\n                    {/* We loop through our filtered `programs` list and create a button for each one. */}\n                    {programs.map(program => (\n                        <button \n                            key={program.id} // A unique key for each item in the list.\n                            onClick={() => handleProgramSelect(program)} // When clicked, run our handler function.\n                            className=\"bg-white p-6 rounded-xl shadow-md hover:shadow-xl hover:-translate-y-1 transition-all duration-300 cursor-pointer flex flex-col items-center text-center\"\n                        >\n                            <div className=\"p-4 bg-red-100 text-red-600 rounded-full mb-4\">\n                                <GraduationCap className=\"w-8 h-8\"/>\n                            </div>\n                            <h3 className=\"text-lg font-bold text-gray-800\">{program.name}</h3>\n                            <p className=\"text-sm text-gray-500\">{data.colleges.find(c => c.id === program.collegeId)?.name}</p>\n                        </button>\n                    ))}\n                </div>\n            </div>\n            {/* This is a conditional render. The `BatchSelectionModal` is only shown\n                if `isModalOpen` is true and a program has been selected. */}\n            {isModalOpen && selectedProgramForBatch && (\n                <BatchSelectionModal \n                    program={selectedProgramForBatch}\n                    onClose={() => setIsModalOpen(false)} // When the modal closes, we set `isModalOpen` back to false.\n                />\n            )}\n        </div>\n    );\n};\n\nexport default ProgramSelectionScreen;",
  "components/BatchSelectionModal.tsx": "/**\n * @file BatchSelectionModal.tsx\n * @description\n * This file defines the `BatchSelectionModal` component. It's the popup window that\n * appears after a user selects a program on the `ProgramSelectionScreen`.\n *\n * Its main job is to:\n * 1.  Show the name of the program the user selected.\n * 2.  Display a dropdown list of available batches for that specific program.\n * 3.  Allow the user to select a batch and click \"Proceed\".\n * 4.  When the user proceeds, it calls a function from our \"magic backpack\" (AppContext)\n *     to save the selected program and batch, allowing the user to enter the main application.\n */\n\nimport React, { useMemo, useState } from 'react';\nimport { useAppContext } from '../hooks/useAppContext'; // Helper to get shared data.\nimport { Program } from '../types'; // Imports the `Program` type from our data dictionary.\n\n// This defines the \"props\" or properties that this component accepts.\ninterface BatchSelectionModalProps {\n  program: Program; // The program that the user selected.\n  onClose: () => void; // A function to call to close the modal.\n}\n\n// This is the main component function for the Batch Selection Modal.\nconst BatchSelectionModal: React.FC<BatchSelectionModalProps> = ({ program, onClose }) => {\n    // We ask our \"magic backpack\" (AppContext) for the data and tools we need.\n    const { data, setProgramAndBatch } = useAppContext();\n    \n    // `useMemo` is a performance helper. It only recalculates this list of batches\n    // when the program changes, preventing unnecessary work.\n    const availableBatches = useMemo(() => {\n        // We filter all batches in our data to find the ones that match the selected program's ID.\n        return data.batches\n            .filter(b => b.programId === program.id)\n            .sort((a,b) => b.name.localeCompare(a.name)); // We sort them to show the newest first.\n    }, [data.batches, program.id]);\n\n    // `useState` gives the component its own memory. Here, we're remembering which\n    // batch is currently selected in the dropdown. We default to the first available batch.\n    const [batch, setBatch] = useState(availableBatches.length > 0 ? availableBatches[0].name : \"\");\n\n    // This function runs when the user clicks the \"Proceed\" button.\n    const handleSubmit = (e: React.FormEvent) => {\n        e.preventDefault(); // Prevents the browser from reloading the page.\n        if (!batch) {\n            alert(\"Please select a batch.\");\n            return;\n        }\n        // This is the most important step: we call the function from our magic backpack\n        // to save the selected program and batch globally for the whole app.\n        setProgramAndBatch(program, batch);\n        onClose(); // Close the modal.\n    }\n\n    // The JSX below describes what the modal looks like.\n    return (\n        // This is the semi-transparent background for the modal.\n        <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n            {/* This is the white content box of the modal. */}\n            <div className=\"bg-white rounded-lg shadow-xl p-8 w-full max-w-sm\">\n                <h2 className=\"text-2xl font-bold mb-2\">Select Batch</h2>\n                <p className=\"mb-6 text-gray-600\">For Program: <span className=\"font-semibold\">{program.name}</span></p>\n                \n                {/* We only show the form if there are batches available. */}\n                {availableBatches.length > 0 ? (\n                    <form onSubmit={handleSubmit}>\n                        <label htmlFor=\"batch-select\" className=\"block text-sm font-medium text-gray-700\">Batch Year</label>\n                        <select\n                            id=\"batch-select\"\n                            value={batch} // The dropdown's value is tied to our component's memory.\n                            onChange={(e) => setBatch(e.target.value)} // When the user changes it, we update the memory.\n                            className=\"mt-1 block w-full pl-3 pr-10 py-2 text-base text-gray-900 bg-white border border-gray-300 focus:outline-none focus:ring-red-500 focus:border-red-500 sm:text-sm rounded-md\"\n                        >\n                            {/* We loop through the available batches and create an <option> for each one. */}\n                            {availableBatches.map(b => <option key={b.id} value={b.name}>{b.name}</option>)}\n                        </select>\n                        <div className=\"mt-6 flex justify-end gap-4\">\n                            <button type=\"button\" onClick={onClose} className=\"px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300\">Cancel</button>\n                            <button type=\"submit\" className=\"px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700\">Proceed</button>\n                        </div>\n                    </form>\n                ) : (\n                    // If there are no batches, we show a helpful message instead.\n                    <div>\n                        <p className=\"text-center text-gray-500 bg-yellow-50 p-4 rounded-md\">\n                            No batches have been created for this program yet. Please contact an Administrator to set up batches.\n                        </p>\n                        <div className=\"mt-6 flex justify-end\">\n                             <button type=\"button\" onClick={onClose} className=\"px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300\">Close</button>\n                        </div>\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n};\n\nexport default BatchSelectionModal;",
  "components/Modal.tsx": "/**\n * @file Modal.tsx\n * @description\n * This file defines a generic and reusable `Modal` component. A modal is a \"popup\"\n * window that appears on top of the main page content.\n *\n * This component is like a blank template for a popup. It provides the basic\n * structure:\n * 1.  A semi-transparent background overlay.\n * 2.  A white content box in the center.\n * 3.  A title bar with a title and a close button.\n *\n * Other components can then use this `Modal` and put whatever content they want\n * inside it by passing `children`. This makes it very flexible and reusable.\n */\n\nimport React from 'react';\n\n// This defines the \"props\" or properties that this component accepts.\ninterface ModalProps {\n  title: string; // The text to display in the modal's title bar.\n  onClose: () => void; // A function to call when the modal should be closed.\n  children: React.ReactNode; // The content to display inside the modal.\n}\n\n// This is the main component function for the Modal.\nconst Modal: React.FC<ModalProps> = ({ title, onClose, children }) => {\n  // The JSX below describes what the modal looks like.\n  return (\n    // This is the full-screen, semi-transparent background.\n    // Clicking on it will call the `onClose` function to close the modal.\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 transition-opacity\" onClick={onClose}>\n      {/* This is the white content box. \n          `onClick={(e) => e.stopPropagation()}` is a clever trick: it prevents a click\n          inside the white box from \"bubbling up\" to the background. This means clicking\n          the content won't close the modal, but clicking the background will. */}\n      <div className=\"bg-white rounded-lg shadow-xl w-full max-w-2xl mx-4 transform transition-all\" onClick={(e) => e.stopPropagation()}>\n        {/* The header section of the modal. */}\n        <div className=\"flex justify-between items-center p-4 border-b border-gray-200\">\n          <h3 className=\"text-xl font-semibold text-gray-800\">{title}</h3>\n          {/* The 'X' close button. */}\n          <button onClick={onClose} className=\"text-gray-400 hover:text-gray-600\" aria-label=\"Close\">\n            <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M6 18L18 6M6 6l12 12\"></path></svg>\n          </button>\n        </div>\n        {/* This is where the `children` (the actual content provided by the parent component) will be rendered. */}\n        <div>{children}</div>\n      </div>\n    </div>\n  );\n};\n\nexport default Modal;",
  "pages/Dashboard.tsx": "/**\n * @file Dashboard.tsx\n * @description\n * This file defines the `Dashboard` component. It's a smart component that acts as a\n * \"dashboard router\", showing different content based on the logged-in user's role.\n *\n * What it does:\n * 1.  **Checks User Role**: It first looks at the `currentUser` from the \"magic backpack\".\n * 2.  **Teacher View**: If the user is a 'Teacher', it renders the specialized `TeacherDashboard`\n *     component, which is designed specifically for their needs.\n * 3.  **Default View**: For all other roles (like Program Co-ordinator, Admin, etc.), it\n *     renders a general dashboard with \"Stat Cards\" showing key numbers for the selected\n *     program and \"Quick Actions\" buttons.\n */\n\nimport React, { useMemo } from 'react';\nimport { useAppContext } from '../hooks/useAppContext'; // Helper to get shared data.\nimport { useNavigate } from 'react-router-dom';\nimport { BookOpen, Users, Target, PieChart } from '../components/Icons'; // Imports icon images.\nimport StatCard from '../components/StatCard'; // Imports the reusable stat card component.\nimport TeacherDashboard from '../components/TeacherDashboard'; // Import the new, specialized dashboard for teachers.\n\n// This is the main component function for the Dashboard.\nconst Dashboard: React.FC = () => {\n    // We ask our \"magic backpack\" (AppContext) for the data and user info we need.\n    const { data, selectedProgram, currentUser } = useAppContext();\n    \n    // `useNavigate` gives us a function to tell the app to go to a different page.\n    const navigate = useNavigate();\n\n    // --- Role-Based Rendering Logic ---\n    // If the current user is a Teacher, we show them their own special dashboard.\n    if (currentUser?.role === 'Teacher') {\n        return <TeacherDashboard />;\n    }\n\n    // --- Default Dashboard for Other Roles ---\n    // The rest of this component will only be rendered if the user is NOT a teacher.\n\n    // `useMemo` is a performance helper. It only recalculates this list of courses\n    // when the underlying data or selected program changes.\n    const programCourses = useMemo(() => {\n        // First, get all courses that belong to the currently selected program.\n        // FIX: The check for 'Teacher' role is redundant here because the TeacherDashboard is\n        // rendered for teachers before this code is reached, causing a type error.\n        const courses = data.courses.filter(c => c.programId === selectedProgram?.id);\n        return courses;\n    }, [data.courses, selectedProgram]);\n\n    // Get all students and Program Outcomes that belong to the selected program.\n    const programStudents = data.students.filter(s => s.programId === selectedProgram?.id);\n    const programPOs = data.programOutcomes.filter(po => po.programId === selectedProgram?.id);\n  \n    // The JSX below describes what the Dashboard looks like for non-teacher roles.\n    return (\n        <div className=\"space-y-6\">\n            {/* This grid displays the four main statistics cards. */}\n            <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6\">\n                <StatCard \n                    title={\"Courses in Program\"} \n                    value={programCourses.length} \n                    icon={<BookOpen />} \n                    color=\"blue\" \n                />\n                <StatCard \n                    title=\"Students in Program\" \n                    value={programStudents.length} \n                    icon={<Users />} \n                    color=\"green\" \n                />\n                <StatCard \n                    title=\"Program Outcomes\" \n                    value={programPOs.length} \n                    icon={<Target />} \n                    color=\"purple\" \n                />\n                <StatCard \n                    title=\"Courses to Assess\" \n                    value={programCourses.length} \n                    icon={<PieChart />} \n                    color=\"red\" \n                />\n            </div>\n            {/* The \"Quick Actions\" section with navigation buttons. */}\n            <div className=\"bg-white p-6 rounded-xl shadow-md\">\n                <h2 className=\"text-xl font-semibold text-gray-700 mb-4\">Quick Actions</h2>\n                <div className=\"flex flex-wrap gap-4\">\n                    {/* When this button is clicked, it uses `navigate` to go to the \"/courses\" page. */}\n                    <button onClick={() => navigate('/courses')} className=\"px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors\">\n                        Manage Courses\n                    </button>\n                    {/* When this button is clicked, it goes to the \"/reports\" page. */}\n                    <button onClick={() => navigate('/reports')} className=\"px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors\">\n                        View Reports\n                    </button>\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport default Dashboard;",
  "components/StatCard.tsx": "/**\n * @file StatCard.tsx\n * @description\n * This file defines the `StatCard` component. It's a small, reusable \"widget\"\n * used on the Dashboard to display a single piece of information, like the total\n * number of students.\n *\n * It's designed to be flexible. You can tell it:\n * - What `title` to show (e.g., \"Total Students\").\n * - What `value` to display (e.g., 120).\n * - Which `icon` to use.\n * - What `color` theme it should have.\n */\n\nimport React from 'react';\n\n// This defines the \"props\" or properties that the component accepts.\n// By being specific, we ensure that anyone using this component provides the right kind of data.\ninterface StatCardProps {\n  title: string;\n  value: string | number;\n  icon: React.ReactElement<{ className?: string }>; // The icon must be a React component that can accept a `className`.\n  color: 'blue' | 'green' | 'purple' | 'red'; // Only these specific colors are allowed.\n}\n\n// This is a helper object that maps our simple color names to the more complex\n// TailwindCSS classes that actually create the color styles.\nconst colorClasses = {\n    blue: 'bg-blue-100 text-blue-600',\n    green: 'bg-green-100 text-green-600',\n    purple: 'bg-purple-100 text-purple-600',\n    red: 'bg-red-100 text-red-600',\n}\n\n// This is the main component function. It receives the props from its parent.\nconst StatCard: React.FC<StatCardProps> = ({ title, value, icon, color }) => (\n  // The main container for the card.\n  <div className=\"bg-white p-6 rounded-xl shadow-md flex items-center\">\n    {/* This is the colored circle that holds the icon.\n        `colorClasses[color]` dynamically picks the right style from our helper object. */}\n    <div className={`p-4 rounded-full ${colorClasses[color]}`}>\n      {/* `React.cloneElement` is used to take the `icon` component we received\n          and add a new property to it (`className`) before rendering it.\n          This is how we give the icon a specific size (w-6 h-6). */}\n      {React.cloneElement(icon, { className: 'w-6 h-6' })}\n    </div>\n    {/* This container holds the text content. */}\n    <div className=\"ml-4\">\n      <p className=\"text-gray-500\">{title}</p>\n      <p className=\"text-2xl font-bold text-gray-800\">{value}</p>\n    </div>\n  </div>\n);\n\nexport default StatCard;",
  "pages/CoursesList.tsx": "/**\n * @file CoursesList.tsx\n * @description\n * This file defines the `CoursesList` component, which is the main page for viewing and\n * managing courses. It's a very dynamic page that changes its appearance and functionality\n * based on the logged-in user's role.\n *\n * Key Responsibilities:\n * 1.  **Display Courses**: Shows courses grouped by their status (\"Active\", \"Future\", \"Completed\").\n * 2.  **Role-Based Filtering**: The list of courses is heavily filtered.\n *     - An **Admin** can see courses for any college/program they select in the sidebar.\n *     - A **Program Co-ordinator** sees all courses for their specific program.\n *     - A **Teacher** only sees the courses they are personally assigned to.\n * 3.  **Course Management (for PC/Admin)**:\n *     - Allows adding a new course manually via a form.\n *     - Allows bulk-uploading courses from an Excel file.\n *     - Allows assigning a teacher to a course via a dropdown.\n *     - Allows changing the status of one or more courses (e.g., from \"Future\" to \"Active\").\n * 4.  **Bulk Actions**: When a user selects multiple courses, a \"bulk action\" bar appears at the top,\n *     allowing them to change the status of all selected courses at once.\n * 5.  **Student Enrollment**: When a course is marked as \"Active\", it automatically enrolls all\n *     active students from the currently selected batch into that course.\n */\n\nimport React, { useState, useMemo } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useAppContext } from '../hooks/useAppContext';\nimport { Course, CourseStatus, Enrollment, User } from '../types';\nimport ExcelUploader from '../components/ExcelUploader';\nimport { ChevronDown, ChevronUp } from '../components/Icons';\nimport ConfirmationModal from '../components/ConfirmationModal';\n\n/**\n * A small helper component that creates a \"collapsible\" section.\n * It shows a title and a count, and when you click it, it expands to show its `children`.\n * It's used to hide the \"Future\" and \"Completed\" course lists until the user wants to see them.\n */\nconst CollapsibleSection: React.FC<{ title: string; children: React.ReactNode; count: number }> = ({ title, children, count }) => {\n    // A piece of memory to remember if this section is open or closed.\n    const [isOpen, setIsOpen] = useState(false);\n    // If there are no items to show in this section, we don't render anything at all.\n    if (count === 0) return null;\n\n    return (\n        <div className=\"bg-white rounded-lg shadow-md\">\n            <button\n                className=\"w-full flex justify-between items-center p-4 text-left font-semibold text-lg text-gray-700\"\n                onClick={() => setIsOpen(!isOpen)} // When clicked, flip the `isOpen` value.\n            >\n                <span>{title} ({count})</span>\n                {/* Show a different arrow icon depending on whether it's open or closed. */}\n                {isOpen ? <ChevronUp className=\"w-6 h-6\" /> : <ChevronDown className=\"w-6 h-6\" />}\n            </button>\n            {/* The `children` are only rendered if `isOpen` is true. */}\n            {isOpen && (\n                <div className=\"border-t border-gray-200\">\n                    {children}\n                </div>\n            )}\n        </div>\n    );\n};\n\n// This is the main component for the Courses List page.\nconst CoursesList: React.FC = () => {\n    // We ask our \"magic backpack\" (AppContext) for all the data and tools we need.\n    const { selectedProgram, selectedBatch, data, setData, currentUser, selectedCollegeId } = useAppContext();\n    const navigate = useNavigate(); // A tool to navigate to other pages.\n\n    // --- State Management ---\n    // Pieces of memory for the \"Add Course\" form.\n    const [newCourseCode, setNewCourseCode] = useState('');\n    const [newCourseName, setNewCourseName] = useState('');\n    // A piece of memory to keep track of which courses the user has selected with checkboxes.\n    const [selectedCourseIds, setSelectedCourseIds] = useState<string[]>([]);\n    \n    // A piece of memory for the confirmation popup (modal).\n    const [confirmation, setConfirmation] = useState<{\n        isOpen: boolean;\n        title: string;\n        message: string;\n        onConfirm: () => void;\n    } | null>(null);\n\n    // Some handy booleans to check the user's role.\n    const isProgramCoordinator = currentUser?.role === 'Program Co-ordinator';\n    const isAdmin = currentUser?.role === 'Admin';\n    const canManageCourses = isProgramCoordinator || isAdmin; // Only PCs and Admins can manage courses.\n\n    /**\n     * `useMemo` is a performance optimization. It's like a smart calculator that only\n     * re-does its calculations when one of its inputs (the values in the `[]` array) changes.\n     * This is a very complex calculation, so we don't want to run it on every single render.\n     */\n    const { activeCourses, futureCourses, completedCourses, teachersForPC, pageTitle } = useMemo(() => {\n        let courses: Course[];\n\n        // --- Step 1: Filter courses based on the user's role and their selections. ---\n        if (isAdmin) {\n            courses = data.courses; // An admin starts with all courses.\n            if (selectedProgram) { // If they selected a program in the sidebar...\n                courses = courses.filter(c => c.programId === selectedProgram.id); // ...filter by that program.\n            } else if (selectedCollegeId) { // If they only selected a college...\n                const programIdsInCollege = new Set(data.programs.filter(p => p.collegeId === selectedCollegeId).map(p => p.id));\n                courses = courses.filter(c => programIdsInCollege.has(c.programId)); // ...filter by all programs in that college.\n            }\n        } else if (currentUser?.role === 'Teacher') {\n            // A teacher only sees courses where they are the main teacher OR assigned to a specific section.\n            courses = data.courses.filter(c => \n                c.teacherId === currentUser.id || \n                (c.sectionTeacherIds && Object.values(c.sectionTeacherIds).includes(currentUser.id))\n            );\n        } else { // This handles Program Co-ordinators and other roles.\n            courses = data.courses.filter((c) => c.programId === selectedProgram?.id);\n        }\n        \n        // Sort the final list of courses alphabetically by code.\n        courses = courses.sort((a, b) => a.code.localeCompare(b.code));\n\n        // --- Step 2: Get the list of teachers that a PC or Admin can assign. ---\n        let teachersForPC: User[] = [];\n        if (isProgramCoordinator) {\n            // A PC can assign any teacher that reports to them.\n            const myManagedTeacherIds = new Set(data.users\n                .filter(u => u.role === 'Teacher' && u.programCoordinatorIds?.includes(currentUser.id))\n                .map(u => u.id));\n            teachersForPC = data.users.filter(u => myManagedTeacherIds.has(u.id));\n        } else if (isAdmin) {\n             // An admin can assign any teacher in the system.\n             teachersForPC = data.users.filter(u => u.role === 'Teacher');\n        }\n\n        // --- Step 3: Determine the title for the page. ---\n        const title = isAdmin\n            ? selectedProgram\n                ? `Courses for ${selectedProgram.name}`\n                : selectedCollegeId\n                    ? `Courses in ${data.colleges.find(c => c.id === selectedCollegeId)?.name}`\n                    : 'All Courses'\n            : currentUser?.role === 'Teacher'\n                ? 'My Assigned Courses'\n                : 'Courses';\n\n        // --- Step 4: Return all the calculated data. ---\n        return {\n            activeCourses: courses.filter(c => c.status === 'Active'),\n            futureCourses: courses.filter(c => c.status === 'Future'),\n            completedCourses: courses.filter(c => c.status === 'Completed'),\n            teachersForPC,\n            pageTitle: title\n        };\n    }, [data, selectedProgram, currentUser, selectedCollegeId, isProgramCoordinator, isAdmin]);\n    \n    // Check if the user has permission to add courses.\n    const canAddCourse = canManageCourses && (isProgramCoordinator || (isAdmin && selectedProgram));\n\n    // This function is called by the ExcelUploader component when a file is successfully parsed.\n    const handleExcelUpload = (uploadedData: { code: string; name: string }[]) => {\n        if (!selectedProgram) {\n             alert(\"Please select a program before bulk uploading courses.\");\n             return;\n        }\n        // Convert the simple data from the Excel file into full `Course` objects.\n        const newCourses: Course[] = uploadedData.map((row, index) => ({\n            id: `c_excel_${Date.now()}_${index}`, code: row.code || 'N/A', name: row.name || 'Untitled Course',\n            programId: selectedProgram.id, target: 50, internalWeightage: 25, externalWeightage: 75,\n            attainmentLevels: { level3: 80, level2: 70, level1: 50 }, status: 'Future', teacherId: null\n        }));\n        // Update the main application data in our magic backpack.\n        setData(prev => ({ ...prev, courses: [...prev.courses, ...newCourses] }));\n    };\n\n    // This runs when the user submits the \"Add Course\" form.\n    const handleAddCourse = (e: React.FormEvent) => {\n        e.preventDefault(); // Stop the page from reloading.\n        if (!newCourseCode.trim() || !newCourseName.trim() || !selectedProgram) return;\n        // Create a new course object from the form data.\n        const newCourse: Course = {\n            id: `c_manual_${Date.now()}`, programId: selectedProgram.id, code: newCourseCode.trim(),\n            name: newCourseName.trim(), target: 50, internalWeightage: 25, externalWeightage: 75,\n            attainmentLevels: { level3: 80, level2: 70, level1: 50 }, status: 'Future', teacherId: null\n        };\n        // Add the new course to our main data.\n        setData(prev => ({ ...prev, courses: [...prev.courses, newCourse] }));\n        // Clear the form fields.\n        setNewCourseCode(''); setNewCourseName('');\n    };\n\n    // This function actually performs the status update after the user confirms.\n    const performStatusUpdate = (ids: string[], newStatus: CourseStatus) => {\n        setData(prev => {\n            let newEnrollments: Enrollment[] = [...prev.enrollments];\n            const updatedCourses = prev.courses.map(c => {\n                if (ids.includes(c.id)) {\n                    // **SPECIAL LOGIC**: If a course is being activated...\n                    if (newStatus === 'Active' && c.status !== 'Active') {\n                        if (selectedProgram && selectedBatch) {\n                            // Find all active students in the currently selected batch.\n                            const batch = prev.batches.find(b => b.programId === selectedProgram.id && b.name === selectedBatch);\n                            if (batch) {\n                                const sectionsForBatch = prev.sections.filter(s => s.batchId === batch.id);\n                                const sectionIdsForBatch = new Set(sectionsForBatch.map(s => s.id));\n                        \n                                const activeStudentsForBatch = prev.students.filter(s => \n                                    s.programId === selectedProgram.id && \n                                    s.status === 'Active' &&\n                                    s.sectionId &&\n                                    sectionIdsForBatch.has(s.sectionId)\n                                );\n                        \n                                // Find which students are already enrolled to avoid duplicates.\n                                const existingEnrollments = new Set(newEnrollments.filter(e => e.courseId === c.id).map(e => e.studentId));\n                                \n                                // Create new enrollment records for the students who aren't already enrolled.\n                                const enrollmentsToAdd = activeStudentsForBatch\n                                    .filter(s => !existingEnrollments.has(s.id))\n                                    .map(s => ({ courseId: c.id, studentId: s.id, sectionId: s.sectionId }));\n                                    \n                                newEnrollments.push(...enrollmentsToAdd);\n                            }\n                        }\n                    }\n                    // Return the course with its new status.\n                    return { ...c, status: newStatus };\n                }\n                return c;\n            });\n            // Return the updated data for both courses and enrollments.\n            return { ...prev, courses: updatedCourses, enrollments: newEnrollments };\n        });\n        // Clean up: clear the selection and close the confirmation modal.\n        setSelectedCourseIds([]);\n        setConfirmation(null);\n    };\n\n    // This function opens the \"Are you sure?\" popup before changing a status.\n    const promptStatusChange = (ids: string[], newStatus: CourseStatus) => {\n        let message = '';\n        if (ids.length === 1) { // A message for a single course.\n            const courseName = data.courses.find(c => c.id === ids[0])?.name;\n            message = `Are you sure you want to mark '${courseName}' as ${newStatus}?`;\n        } else { // A message for multiple courses.\n            message = `Are you sure you want to mark ${ids.length} selected courses as ${newStatus}?`;\n        }\n        // Add an extra warning if activating a course.\n        if (newStatus === 'Active') {\n            if (!selectedBatch) {\n                alert(\"Please select a batch from the sidebar before activating a course.\");\n                return;\n            }\n            message += ` This will enroll all active students from the ${selectedBatch} batch into the course.`;\n        }\n        // Open the confirmation modal with the correct message and action.\n        setConfirmation({\n            isOpen: true, title: 'Confirm Status Change', message,\n            onConfirm: () => performStatusUpdate(ids, newStatus),\n        });\n    };\n    \n    // This function actually assigns the teacher after confirmation.\n    const performTeacherAssignment = (courseId: string, teacherId: string) => {\n        setData(prev => ({\n            ...prev,\n            courses: prev.courses.map(c => \n                c.id === courseId ? { ...c, teacherId: teacherId || null } : c\n            )\n        }));\n        setConfirmation(null);\n    };\n\n    // This runs when a PC changes the teacher in the dropdown for a course.\n    const handleAssignTeacherChange = (courseId: string, newTeacherId: string) => {\n        const course = data.courses.find(c => c.id === courseId);\n        if (!course) return;\n\n        // If the course already has a different teacher, show a confirmation popup.\n        if (course.teacherId && course.teacherId !== newTeacherId) {\n             setConfirmation({\n                isOpen: true,\n                title: 'Confirm Teacher Reassignment',\n                message: \"Changing the assigned teacher will unassign the course from the previous teacher. Are you sure you want to proceed?\",\n                onConfirm: () => performTeacherAssignment(courseId, newTeacherId),\n            });\n        } else {\n            // If there was no previous teacher, just assign them directly.\n            performTeacherAssignment(courseId, newTeacherId);\n        }\n    };\n\n    // --- Selection Handlers ---\n    const handleToggleSelection = (courseId: string) => {\n        setSelectedCourseIds(prev =>\n            prev.includes(courseId) ? prev.filter(id => id !== courseId) : [...prev, courseId]\n        );\n    };\n    \n    const handleToggleSelectAll = (courseIds: string[]) => {\n        const allSelected = courseIds.every(id => selectedCourseIds.includes(id));\n        if (allSelected) { // If all are selected, unselect them all.\n            setSelectedCourseIds(prev => prev.filter(id => !courseIds.includes(id)));\n        } else { // Otherwise, select them all.\n            setSelectedCourseIds(prev => [...new Set([...prev, ...courseIds])]);\n        }\n    };\n\n    /**\n     * A reusable function to render a table of courses.\n     * We pass it a list of courses, and it returns the JSX for the table.\n     */\n    const renderCourseTable = (courses: Course[]) => {\n        const courseIds = courses.map(c => c.id);\n        const areAllSelected = courseIds.length > 0 && courseIds.every(id => selectedCourseIds.includes(id));\n\n        return (\n            <div className=\"overflow-x-auto\">\n                <table className=\"min-w-full\">\n                    <thead className=\"bg-gray-50\">\n                        <tr>\n                            {canManageCourses && <th className=\"p-4 text-left\"><input type=\"checkbox\" checked={areAllSelected} onChange={() => handleToggleSelectAll(courseIds)} className=\"h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500\" /></th>}\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">Course Code</th>\n                            <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">Course Name</th>\n                            {(isProgramCoordinator || isAdmin) && <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">Assigned Teacher</th>}\n                            {canManageCourses && <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">Status</th>}\n                            <th className=\"px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody className=\"divide-y divide-gray-200\">\n                        {courses.map((course) => (\n                            <tr key={course.id} className={`hover:bg-gray-50 ${selectedCourseIds.includes(course.id) ? 'bg-indigo-50' : ''}`}>\n                                {canManageCourses && <td className=\"p-4\"><input type=\"checkbox\" checked={selectedCourseIds.includes(course.id)} onChange={() => handleToggleSelection(course.id)} className=\"h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500\" /></td>}\n                                <td className=\"px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900\">{course.code}</td>\n                                <td className=\"px-6 py-4 whitespace-nowrap text-sm text-gray-600\">{course.name}</td>\n                                {(isProgramCoordinator || isAdmin) && (\n                                     <td className=\"px-6 py-4 whitespace-nowrap text-sm\">\n                                         <select\n                                             value={course.teacherId || ''}\n                                             onChange={(e) => handleAssignTeacherChange(course.id, e.target.value)}\n                                             className=\"p-2 border bg-white text-gray-900 border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm\"\n                                         >\n                                             <option value=\"\">-- Unassigned --</option>\n                                             {teachersForPC.map(teacher => (\n                                                 <option key={teacher.id} value={teacher.id}>{teacher.name}</option>\n                                             ))}\n                                         </select>\n                                     </td>\n                                )}\n                                {canManageCourses && (\n                                    <td className=\"px-6 py-4 whitespace-nowrap text-sm text-gray-600\">\n                                        <select value={course.status} onChange={(e) => promptStatusChange([course.id], e.target.value as CourseStatus)} className=\"p-2 border bg-white text-gray-900 border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm\">\n                                            <option value=\"Future\">Future</option>\n                                            <option value=\"Active\">Active</option>\n                                            <option value=\"Completed\">Completed</option>\n                                        </select>\n                                    </td>\n                                )}\n                                <td className=\"px-6 py-4 whitespace-nowrap text-right text-sm font-medium\">\n                                    <button onClick={() => navigate(`/courses/${course.id}`)} className=\"text-indigo-600 hover:text-indigo-800\">Manage</button>\n                                </td>\n                            </tr>\n                        ))}\n                    </tbody>\n                </table>\n            </div>\n        );\n    };\n\n    // --- Main Render Logic ---\n    // If the user is a Teacher, we show a simplified, read-only view.\n    if (currentUser?.role === 'Teacher') {\n        return (\n           <div className=\"space-y-8\">\n              <h1 className=\"text-3xl font-bold text-gray-800\">{pageTitle}</h1>\n              <div className=\"bg-white rounded-lg shadow-md\">\n                <h2 className=\"text-xl font-bold text-gray-800 p-4 border-b\">Active Courses ({activeCourses.length})</h2>\n                {renderCourseTable(activeCourses)}\n              </div>\n              <CollapsibleSection title=\"Completed Courses\" count={completedCourses.length}>\n                  {renderCourseTable(completedCourses)}\n              </CollapsibleSection>\n              <CollapsibleSection title=\"Future Courses\" count={futureCourses.length}>\n                  {renderCourseTable(futureCourses)}\n              </CollapsibleSection>\n           </div>\n        );\n    }\n\n    // This is the full view for PCs and Admins.\n    return (\n        <div className=\"space-y-6\">\n            <div className=\"flex justify-between items-center\">\n                <h1 className=\"text-3xl font-bold text-gray-800\">{pageTitle}</h1>\n                {canAddCourse && (<ExcelUploader<{ code: string; name: string }> onFileUpload={handleExcelUpload} label=\"Bulk Upload\" format=\"cols: code, name\" />)}\n            </div>\n\n            {canAddCourse && (\n                <div className=\"bg-white p-4 rounded-lg shadow-md\">\n                    <form onSubmit={handleAddCourse} className=\"flex flex-wrap md:flex-nowrap gap-4 items-end\">\n                        <div className=\"flex-grow\"><label htmlFor=\"new-course-code\" className=\"text-sm font-medium text-gray-600 block\">Course Code</label><input id=\"new-course-code\" type=\"text\" placeholder=\"e.g. CS101\" value={newCourseCode} onChange={e => setNewCourseCode(e.target.value)} className=\"w-full p-2 mt-1 border border-gray-300 rounded-md bg-white text-gray-900\" required /></div>\n                        <div className=\"flex-grow-[2]\"><label htmlFor=\"new-course-name\" className=\"text-sm font-medium text-gray-600 block\">Course Name</label><input id=\"new-course-name\" type=\"text\" placeholder=\"e.g. Intro to Programming\" value={newCourseName} onChange={e => setNewCourseName(e.target.value)} className=\"w-full p-2 mt-1 border border-gray-300 rounded-md bg-white text-gray-900\" required /></div>\n                        <button type=\"submit\" className=\"bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg h-[42px] w-full md:w-auto\">Add Course</button>\n                    </form>\n                </div>\n            )}\n            \n            {/* The bulk action bar only appears if one or more courses are selected. */}\n            {selectedCourseIds.length > 0 && (\n                <div className=\"bg-gray-800 text-white p-4 rounded-lg shadow-lg flex items-center justify-between sticky top-2 z-10\">\n                    <span className=\"font-semibold\">{selectedCourseIds.length} course(s) selected</span>\n                    <div className=\"flex gap-2\">\n                        <button onClick={() => promptStatusChange(selectedCourseIds, 'Future')} className=\"bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-lg text-sm\">Mark as Future</button>\n                        <button onClick={() => promptStatusChange(selectedCourseIds, 'Active')} className=\"bg-blue-600 hover:bg-blue-500 text-white font-bold py-1 px-3 rounded-lg text-sm\">Mark as Active</button>\n                        <button onClick={() => promptStatusChange(selectedCourseIds, 'Completed')} className=\"bg-green-600 hover:bg-green-500 text-white font-bold py-1 px-3 rounded-lg text-sm\">Mark as Completed</button>\n                    </div>\n                </div>\n            )}\n\n            <div className=\"bg-white rounded-lg shadow-md\">\n                <h2 className=\"text-xl font-bold text-gray-800 p-4 border-b\">Active Courses ({activeCourses.length})</h2>\n                {renderCourseTable(activeCourses)}\n            </div>\n\n            <CollapsibleSection title=\"Future Courses\" count={futureCourses.length}>\n                {renderCourseTable(futureCourses)}\n            </CollapsibleSection>\n\n            <CollapsibleSection title=\"Completed Courses\" count={completedCourses.length}>\n                {renderCourseTable(completedCourses)}\n            </CollapsibleSection>\n\n            {/* The confirmation modal is only rendered if it has been activated. */}\n            {confirmation && (\n                <ConfirmationModal \n                    isOpen={confirmation.isOpen}\n                    title={confirmation.title}\n                    message={confirmation.message}\n                    onConfirm={confirmation.onConfirm}\n                    onClose={() => setConfirmation(null)}\n                />\n            )}\n        </div>\n    );\n};\n\nexport default CoursesList;",
  "pages/CourseDetail.tsx": "/**\n * @file CourseDetail.tsx\n * @description\n * This component acts as the main \"hub\" or \"container\" for managing a single, specific course.\n * It doesn't have much logic itself; its primary job is to provide a tabbed interface and\n * render the correct component for the currently selected tab.\n *\n * How it works:\n * 1.  It uses the `useParams` hook from React Router to read the `courseId` from the URL.\n *     For example, in `/courses/C101`, it knows that `courseId` is \"C101\".\n * 2.  It finds the full course object from our main application data using this ID.\n * 3.  It keeps track of which tab is currently `activeTab` in its memory (state).\n * 4.  It displays a list of tab buttons. When a user clicks a button, it updates `activeTab`.\n * 5.  Based on the value of `activeTab`, it uses a `switch` statement to render the\n *     appropriate component (e.g., `ManageCourseOutcomes`, `CoPoMappingMatrix`, etc.).\n * 6.  It also performs a security check to ensure that a Teacher cannot view the details\n *     of a course they are not assigned to.\n */\n\nimport React, { useState, useMemo } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { useAppContext } from '../hooks/useAppContext';\n// Importing all the different components that will live inside the tabs.\nimport ManageCourseOutcomes from '../components/ManageCourseOutcomes';\nimport ManageCourseAssessments from '../components/ManageCourseAssessments';\nimport CoPoMappingMatrix from '../components/CoPoMappingMatrix';\nimport CourseOverviewTab from '../components/CourseOverviewTab';\nimport StudentCOAttainmentReport from './StudentCOAttainmentReport';\nimport CourseFacultyAssignment from '../components/CourseFacultyAssignment';\nimport CourseCoAttainment from '../components/CourseCoAttainment';\nimport { Course } from '../types';\n\n// This defines the possible values for our `activeTab` state.\ntype Tab = 'Overview' | 'COs' | 'Assessments' | 'CO-PO Mapping' | 'CO Attainments' | 'Student Reports' | 'Faculty Assignment';\n\nconst CourseDetail: React.FC = () => {\n  // `useParams` is a hook from React Router that gives us access to URL parameters.\n  const { courseId } = useParams<{ courseId: string }>();\n  // We get our app's data and the current user from the \"magic backpack\".\n  const { data, currentUser } = useAppContext();\n  // A piece of memory to remember which tab is currently active. Defaults to 'Overview'.\n  const [activeTab, setActiveTab] = useState<Tab>('Overview');\n\n  // Find the course object that matches the ID from the URL.\n  // `useMemo` is used here for a small performance optimization.\n  const course = useMemo(() => data.courses.find(c => c.id === courseId), [courseId, data.courses]);\n  \n  // --- Security Check ---\n  // If the user is a Teacher, we check if they are actually assigned to this course.\n  if (currentUser?.role === 'Teacher' && course && course.teacherId !== currentUser.id && (!course.sectionTeacherIds || !Object.values(course.sectionTeacherIds).includes(currentUser.id))) {\n    // If they are not assigned, we show an \"Access Denied\" message and stop rendering.\n    return (\n        <div className=\"text-center p-8 bg-white rounded-lg shadow-md\">\n            <h1 className=\"text-2xl font-bold text-red-600\">Access Denied</h1>\n            <p className=\"text-gray-500 mt-2\">You are not assigned to this course.</p>\n        </div>\n    );\n  }\n\n  // If the course ID from the URL doesn't match any course in our data, show an error.\n  if (!course) {\n    return <div className=\"text-center text-red-500 p-8\">Course not found.</div>;\n  }\n\n  // Check the user's role to determine which tabs they should see.\n  const isCoordinator = currentUser?.role === 'Program Co-ordinator';\n  const isAdmin = currentUser?.role === 'Admin';\n\n  // This is the list of tabs that everyone can see.\n  const tabs: Tab[] = ['Overview', 'COs', 'Assessments', 'CO-PO Mapping', 'CO Attainments'];\n\n  // Only Coordinators and Admins can see the \"Faculty Assignment\" tab.\n  if (isCoordinator || isAdmin) {\n    tabs.push('Faculty Assignment');\n  }\n  \n  // Everyone can see the student reports.\n  tabs.push('Student Reports');\n\n\n  /**\n   * This function acts like a router for the tabs. It looks at the `activeTab`\n   * and returns the correct component to display.\n   */\n  const renderContent = () => {\n    switch (activeTab) {\n      case 'Overview':\n        return <CourseOverviewTab course={course} />;\n      case 'COs':\n        return <ManageCourseOutcomes />;\n      case 'Assessments':\n        return <ManageCourseAssessments course={course} />;\n      case 'CO-PO Mapping':\n        return <CoPoMappingMatrix />;\n      case 'CO Attainments':\n        return <CourseCoAttainment course={course} />;\n      case 'Faculty Assignment':\n        // A final check here to make sure only authorized roles see this content.\n        return (isCoordinator || isAdmin) ? <CourseFacultyAssignment course={course} /> : null;\n      case 'Student Reports':\n        return <StudentCOAttainmentReport />;\n      default:\n        return null;\n    }\n  };\n\n  // The JSX below describes what the layout of the page.\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h1 className=\"text-3xl font-bold text-gray-800\">{course.name} ({course.code})</h1>\n          <p className=\"text-gray-500\">Manage course details, outcomes, and assessments.</p>\n        </div>\n      </div>\n\n      {/* The navigation bar for the tabs. */}\n      <div className=\"border-b border-gray-200\">\n        <nav className=\"-mb-px flex space-x-8 overflow-x-auto\" aria-label=\"Tabs\">\n          {/* We loop through our `tabs` array and create a button for each one. */}\n          {tabs.map(tab => (\n            <button\n              key={tab}\n              onClick={() => setActiveTab(tab)} // When a button is clicked, we update the `activeTab`.\n              // This dynamically changes the button's style to highlight the active tab.\n              className={`${ \n                activeTab === tab\n                  ? 'border-indigo-500 text-indigo-600' // Style for the active tab\n                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300' // Style for inactive tabs\n              } whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors`}\n            >\n              {tab}\n            </button>\n          ))}\n        </nav>\n      </div>\n      \n      {/* This is where the content for the active tab will be rendered. */}\n      <div className=\"bg-white p-6 rounded-lg shadow-md min-h-[400px]\">\n        {renderContent()}\n      </div>\n    </div>\n  );\n};\n\n\nexport default CourseDetail;",
  "components/ManageCourseOutcomes.tsx": "/**\n * @file ManageCourseOutcomes.tsx\n * @description\n * This component is the \"COs\" tab within the `CourseDetail` page. It's where a user can\n * manage all the Course Outcomes for a specific course.\n *\n * What it does:\n * 1.  Displays a table of all existing COs for the course.\n * 2.  Allows authorized users (Teachers, PCs) to add a new CO via a form at the bottom of the table.\n * 3.  Allows users to upload a list of COs from an Excel file.\n * 4.  Provides \"Edit\" and \"Delete\" buttons for each CO. Editing happens \"inline\" (directly in the table).\n * 5.  Uses a \"draft state\" pattern: Changes like adding, editing, or deleting are not saved\n *     immediately. They are held in a temporary \"draft\" state, which triggers the `SaveBar`\n *     to appear, allowing the user to save all changes at once or cancel them.\n */\n\nimport React, { useState, useMemo, useEffect } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { CourseOutcome } from '../types';\nimport { useAppContext } from '../hooks/useAppContext';\nimport ExcelUploader from './ExcelUploader';\nimport SaveBar from './SaveBar';\n\nconst ManageCourseOutcomes: React.FC = () => {\n  // `useParams` gets the `courseId` from the URL, so we know which course we're working with.\n  const { courseId } = useParams<{ courseId: string }>();\n  // We get our app's data, tools, and the current user from the \"magic backpack\".\n  const { data, setData, currentUser } = useAppContext();\n\n  // --- State Management for Drafts and Forms ---\n  // `draftOutcomes` is our temporary copy of the COs. Any changes are made to this copy first.\n  const [draftOutcomes, setDraftOutcomes] = useState<CourseOutcome[]>([]);\n  // `initialOutcomes` is a snapshot of the saved data. We compare it with the draft to see if there are unsaved changes.\n  const [initialOutcomes, setInitialOutcomes] = useState<CourseOutcome[]>([]);\n\n  // `useEffect` runs code \"on the side\". This code runs whenever the course changes.\n  // It loads the COs for the current course into both our draft and initial states.\n  useEffect(() => {\n    if (!courseId) return;\n    const outcomesForCourse = data.courseOutcomes.filter(co => co.courseId === courseId);\n    setDraftOutcomes(outcomesForCourse);\n    setInitialOutcomes(outcomesForCourse);\n  }, [data.courseOutcomes, courseId]);\n\n  // `isDirty` is a boolean that tells us if there are unsaved changes.\n  // `useMemo` is a \"smart calculator\" that only re-calculates this value when the draft or initial state changes.\n  // It compares the text versions of the two arrays to see if they are different.\n  const isDirty = useMemo(() => JSON.stringify(draftOutcomes) !== JSON.stringify(initialOutcomes), [draftOutcomes, initialOutcomes]);\n\n  // This `useMemo` automatically calculates the next available CO number (e.g., \"CO5\").\n  const nextCoNumber = useMemo(() => {\n    const highestNum = draftOutcomes.reduce((max, co) => {\n      const num = parseInt(co.number.replace('CO', ''), 10);\n      return !isNaN(num) && num > max ? num : max;\n    }, 0);\n    return `CO${highestNum + 1}`;\n  }, [draftOutcomes]);\n\n  // State for the \"Add New CO\" form fields.\n  const [newCoNumber, setNewCoNumber] = useState(nextCoNumber);\n  const [newCoDescription, setNewCoDescription] = useState('');\n\n  // This `useEffect` keeps the \"Add New CO\" number field up-to-date.\n  useEffect(() => {\n    setNewCoNumber(nextCoNumber);\n  }, [nextCoNumber]);\n\n  // State for handling inline editing.\n  const [editingCoId, setEditingCoId] = useState<string | null>(null); // Which CO are we editing?\n  const [editingText, setEditingText] = useState({ number: '', description: '' }); // The text in the edit inputs.\n\n  // Check if the current user has permission to make changes.\n  const canManage = currentUser?.role === 'Teacher' || currentUser?.role === 'Program Co-ordinator';\n\n  // This function is called by the ExcelUploader when a file is parsed.\n  const handleExcelUpload = (uploadedData: { code: string; description: string }[]) => {\n    if (!courseId) return;\n    // Convert the data from the Excel file into full `CourseOutcome` objects.\n    const newOutcomes: CourseOutcome[] = uploadedData\n      .filter(row => row.code && row.description)\n      .map((row, i) => ({\n        id: `co_excel_${Date.now()}_${i}`,\n        courseId: courseId,\n        number: row.code,\n        description: row.description\n      }));\n    \n    // Add the new outcomes to our draft state.\n    setDraftOutcomes(prev => [...prev, ...newOutcomes]);\n    alert(`${newOutcomes.length} COs staged for upload. Click 'Save Changes' to commit.`);\n  };\n\n  // This runs when the \"Add\" button is clicked for a new CO.\n  const handleAddCo = () => {\n    if (!newCoDescription.trim() || !courseId) {\n      alert(\"Please fill in the Description.\");\n      return;\n    }\n    const newCo: CourseOutcome = {\n      id: `co_manual_${Date.now()}`,\n      courseId,\n      number: newCoNumber.trim(),\n      description: newCoDescription.trim()\n    };\n    // Add the new CO to our draft and clear the input field.\n    setDraftOutcomes(prev => [...prev, newCo]);\n    setNewCoDescription('');\n  };\n\n  // This runs when the \"Delete\" button is clicked for a CO.\n  const handleDeleteCo = (coId: string) => {\n    if (window.confirm(\"Are you sure you want to remove this Course Outcome? This change will be saved when you click 'Save Changes'.\")) {\n      // It only removes the CO from the draft state.\n      setDraftOutcomes(prev => prev.filter(co => co.id !== coId));\n    }\n  };\n\n  // This runs when the \"Edit\" button is clicked. It prepares the inline editing form.\n  const handleEditStart = (co: CourseOutcome) => {\n    setEditingCoId(co.id);\n    setEditingText({ number: co.number, description: co.description });\n  };\n\n  // This runs when the \"Cancel\" button is clicked during an inline edit.\n  const handleEditCancel = () => {\n    setEditingCoId(null);\n    setEditingText({ number: '', description: '' });\n  };\n\n  // This runs when the \"Apply\" button is clicked during an inline edit.\n  const handleEditSave = () => {\n    if (!editingCoId || !editingText.number.trim() || !editingText.description.trim()) return;\n    // It updates the CO in our draft state with the new text.\n    setDraftOutcomes(prev => prev.map(co =>\n      co.id === editingCoId\n        ? { ...co, number: editingText.number.trim(), description: editingText.description.trim() }\n        : co\n    ));\n    handleEditCancel(); // Close the inline edit form.\n  };\n\n  // This runs when the user clicks \"Save Changes\" in the SaveBar.\n  const handleSave = () => {\n    if (!courseId) return;\n    // This is where we finally update the main application data in the \"magic backpack\".\n    setData(prev => ({\n      ...prev,\n      courseOutcomes: [\n        ...prev.courseOutcomes.filter(co => co.courseId !== courseId), // Remove all old COs for this course.\n        ...draftOutcomes // Add all the COs from our draft.\n      ]\n    }));\n    // After saving, the draft becomes the new \"initial\" state, so `isDirty` becomes false.\n    setInitialOutcomes(draftOutcomes);\n    alert(\"Course Outcomes saved successfully!\");\n  };\n  \n  // This runs when the user clicks \"Cancel\" in the SaveBar. It discards all changes.\n  const handleCancel = () => {\n    setDraftOutcomes(initialOutcomes);\n    setEditingCoId(null); // Also cancel any active inline edit.\n  };\n\n  return (\n    // The `pb-20` adds padding at the bottom so the SaveBar doesn't cover content.\n    <div className=\"space-y-6 pb-20\">\n      <div className=\"flex justify-between items-center\">\n        <h2 className=\"text-xl font-semibold text-gray-700\">Manage Course Outcomes (COs)</h2>\n        {canManage && (\n          <ExcelUploader<{ code: string; description: string }>\n            onFileUpload={handleExcelUpload}\n            label=\"Upload COs\"\n            format=\"columns: code, description\"\n          />\n        )}\n      </div>\n\n      <div className=\"overflow-x-auto border border-gray-200 rounded-lg\">\n        <table className=\"min-w-full divide-y divide-gray-200\">\n          <thead className=\"bg-gray-50\">\n            <tr>\n              <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/6\">CO Code</th>\n              <th className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">Description</th>\n              {canManage && <th className=\"px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider w-1/6\">Actions</th>}\n            </tr>\n          </thead>\n          <tbody className=\"bg-white divide-y divide-gray-200\">\n            {draftOutcomes.map(co => (\n              <tr key={co.id}>\n                {/* If we are editing this CO, show input fields. Otherwise, show text. */}\n                {editingCoId === co.id ? (\n                  <>\n                    <td className=\"px-6 py-4\">\n                      <input type=\"text\" value={editingText.number} onChange={(e) => setEditingText({ ...editingText, number: e.target.value })} className=\"w-full p-2 border border-gray-300 rounded-md\"/>\n                    </td>\n                    <td className=\"px-6 py-4\">\n                      <input type=\"text\" value={editingText.description} onChange={(e) => setEditingText({ ...editingText, description: e.target.value })} className=\"w-full p-2 border border-gray-300 rounded-md\"/>\n                    </td>\n                    <td className=\"px-6 py-4 whitespace-nowrap text-right text-sm font-medium\">\n                      <button onClick={handleEditSave} className=\"text-green-600 hover:text-green-800 mr-4\">Apply</button>\n                      <button onClick={handleEditCancel} className=\"text-gray-600 hover:text-gray-800\">Cancel</button>\n                    </td>\n                  </>\n                ) : (\n                  <>\n                    <td className=\"px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900\">{co.number}</td>\n                    <td className=\"px-6 py-4 whitespace-normal text-sm text-gray-600\">{co.description}</td>\n                    {canManage && (\n                      <td className=\"px-6 py-4 whitespace-nowrap text-right text-sm font-medium\">\n                        <button onClick={() => handleEditStart(co)} className=\"text-indigo-600 hover:text-indigo-800 mr-4\">Edit</button>\n                        <button onClick={() => handleDeleteCo(co.id)} className=\"text-red-600 hover:text-red-800\">Delete</button>\n                      </td>\n                    )}\n                  </>\n                )}\n              </tr>\n            ))}\n            {/* The \"Add New CO\" form row is only shown if the user can manage and is not currently editing another CO. */}\n            {canManage && editingCoId === null && (\n              <tr className=\"bg-gray-50/50\">\n                <td className=\"px-6 py-4\">\n                  <input type=\"text\" value={newCoNumber} readOnly className=\"w-full p-2 border border-gray-300 rounded-md bg-gray-100 text-gray-500 cursor-not-allowed focus:ring-0 focus:border-gray-300\"/>\n                </td>\n                <td className=\"px-6 py-4\">\n                  <input type=\"text\" placeholder=\"Description Input\" value={newCoDescription} onChange={(e) => setNewCoDescription(e.target.value)} className=\"w-full p-2 border border-gray-300 rounded-md bg-white text-gray-900 placeholder-gray-400 focus:ring-indigo-500 focus:border-indigo-500\"/>\n                </td>\n                <td className=\"px-6 py-4 text-right\">\n                  <button onClick={handleAddCo} className=\"bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg\">\n                    Add\n                  </button>\n                </td>\n              </tr>\n            )}\n          </tbody>\n        </table>\n      </div>\n      {/* The SaveBar is only visible if `isDirty` is true. */}\n      <SaveBar isDirty={isDirty} onSave={handleSave} onCancel={handleCancel} />\n    </div>\n  );\n};\n\nexport default ManageCourseOutcomes;",
  "components/ManageCourseAssessments.tsx": "/**\n * @file ManageCourseAssessments.tsx\n * @description\n * This component is the \"Assessments\" tab within the `CourseDetail` page. It's the starting\n * point for managing all tests, exams, and assignments for a course.\n *\n * A key architectural point is that assessments are tied to specific **Sections** (class groups),\n * not just the course in general. This component manages that complexity.\n *\n * What it does:\n * 1.  **Section Selection**: It displays a dropdown to select a specific class section.\n *     The list of sections is filtered based on the user's role:\n *     - A **Teacher** only sees the sections they are assigned to for this course.\n *     - A **PC** or **Admin** sees all sections that have students enrolled in this course.\n * 2.  **Display Assessments**: Once a section is selected, it shows a list of all assessments\n *     created for that section.\n * 3.  **Create Assessments**: It provides a \"Create Assessment\" button (which opens a modal)\n *     to create new assessments for the selected section.\n * 4.  **Navigation**: It acts as a navigator. When a user clicks \"Manage Questions\" on an\n *     assessment, it hides the list view and shows the detailed `AssessmentDetails` component\n *     for that specific assessment.\n */\n\nimport React, { useState, useMemo, useEffect } from 'react';\nimport { Course } from '../types';\nimport { useAppContext } from '../hooks/useAppContext';\nimport AssessmentDetails from './AssessmentDetails';\nimport CreateAssessmentModal from './CreateAssessmentModal';\n\n// This defines the \"props\" or properties that this component accepts.\ninterface ManageCourseAssessmentsProps {\n  course: Course; // It receives the full `Course` object it's working with.\n}\n\nconst ManageCourseAssessments: React.FC<ManageCourseAssessmentsProps> = ({ course }) => {\n  // We get our app's data, tools, and the current user from the \"magic backpack\".\n  const { data, setData, currentUser } = useAppContext();\n\n  // --- State Management ---\n  // A piece of memory to remember which assessment the user wants to see details for.\n  const [selectedAssessmentId, setSelectedAssessmentId] = useState<string | null>(null);\n  // A piece of memory to remember which class section is currently selected in the dropdown.\n  const [selectedSectionId, setSelectedSectionId] = useState<string | null>(null);\n  // A piece of memory to control whether the \"Create Assessment\" popup is open.\n  const [isCreateModalOpen, setCreateModalOpen] = useState(false);\n\n  // A simple boolean to check if the user is a PC or Admin.\n  const isPC = currentUser?.role === 'Program Co-ordinator' || currentUser?.role === 'Admin';\n\n  // `useMemo` is a \"smart calculator\" that only recalculates this list of sections when its dependencies change.\n  // This is where the complex role-based filtering of the dropdown happens.\n  const sectionsForDropdown = useMemo(() => {\n    // First, find all sections that have students enrolled in this course. This is our master list.\n    const enrolledSectionIds = new Set(data.enrollments.filter(e => e.courseId === course.id && e.sectionId).map(e => e.sectionId));\n    const allCourseSections = data.sections.filter(s => enrolledSectionIds.has(s.id));\n\n    // If the user is a PC or Admin, they can see all sections.\n    if (isPC) {\n        return allCourseSections;\n    }\n    \n    // If the user is not a Teacher, they see nothing.\n    if (!currentUser || currentUser.role !== 'Teacher') return [];\n    \n    // For a Teacher, find the sections they are explicitly assigned to for this course.\n    const teacherSectionIds = Object.entries(course.sectionTeacherIds || {})\n        .filter(([, teacherId]) => teacherId === currentUser.id)\n        .map(([sectionId]) => sectionId);\n\n    if (teacherSectionIds.length > 0) {\n        // If they have specific section assignments, they only see those sections.\n        return allCourseSections.filter(s => teacherSectionIds.includes(s.id));\n    }\n    \n    // If they have no specific assignments but are the main teacher for the course, they see all sections.\n    if (course.teacherId === currentUser.id) {\n        return allCourseSections; \n    }\n\n    // Otherwise, the teacher has no access to any sections for this course.\n    return [];\n  }, [data.enrollments, data.sections, course, currentUser, isPC]);\n\n  // `useEffect` runs \"on the side\". This effect automatically selects the first section\n  // in the dropdown if no section is currently selected.\n  useEffect(() => {\n    if (sectionsForDropdown.length > 0 && !sectionsForDropdown.some(s => s.id === selectedSectionId)) {\n        setSelectedSectionId(sectionsForDropdown[0].id);\n    } else if (sectionsForDropdown.length === 0) {\n        setSelectedSectionId(null);\n    }\n  }, [sectionsForDropdown, selectedSectionId]);\n\n  // This effect resets the view. If the user changes the section, we should go back\n  // from the details view to the list view.\n  useEffect(() => {\n    setSelectedAssessmentId(null);\n  }, [selectedSectionId]);\n\n  // `useMemo` calculates the list of assessments to show based on the `selectedSectionId`.\n  const assessments = useMemo(() => {\n    if (!selectedSectionId) return [];\n    return data.assessments.filter(a => a.sectionId === selectedSectionId);\n  }, [data.assessments, selectedSectionId]);\n\n  // This function handles deleting an assessment.\n  const handleDeleteAssessment = (assessmentId: string) => {\n    if (window.confirm(\"Are you sure you want to delete this assessment and all its questions and marks? This action cannot be undone.\")) {\n      setData(prev => ({\n        ...prev,\n        assessments: prev.assessments.filter(a => a.id !== assessmentId), // Remove the assessment.\n        marks: prev.marks.filter(m => m.assessmentId !== assessmentId) // Also remove all associated marks.\n      }));\n    }\n  }\n  \n  // A helper to get the name of the currently selected section for display.\n  const sectionName = sectionsForDropdown.find(s => s.id === selectedSectionId)?.name || '';\n\n  // The JSX for the section dropdown, stored in a variable so it can be reused.\n  const SectionSelector = (\n    <div className=\"mb-6 pb-4 border-b\">\n        <label htmlFor=\"section-select\" className=\"block text-sm font-medium text-gray-700\">Select Section</label>\n        <select id=\"section-select\" value={selectedSectionId || ''} onChange={(e) => setSelectedSectionId(e.target.value)} disabled={sectionsForDropdown.length === 0} className=\"mt-1 block w-full max-w-sm pl-3 pr-10 py-2 text-base bg-white text-gray-900 border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md disabled:bg-gray-100\">\n            {sectionsForDropdown.map(section => (\n                <option key={section.id} value={section.id}>Section {section.name}</option>\n            ))}\n        </select>\n        {sectionsForDropdown.length === 0 && <p className=\"mt-2 text-sm text-gray-500\">You are not assigned to any sections for this course, or no sections have been created.</p>}\n    </div>\n  );\n\n  // --- Main Render Logic ---\n  // If an assessment has been selected, we show the details view.\n  if (selectedAssessmentId) {\n    return (\n        <div className=\"space-y-6\">\n            {isPC && SectionSelector} {/* A PC can still switch sections from the details view. */}\n            <AssessmentDetails \n                assessmentId={selectedAssessmentId} \n                onBack={() => setSelectedAssessmentId(null)} // Pass a function to go back.\n                course={course}\n            />\n        </div>\n    );\n  }\n\n  // Otherwise, we show the list view.\n  return (\n    <div className=\"space-y-6\">\n      {SectionSelector}\n      <div className=\"flex justify-between items-center\">\n        <h2 className=\"text-xl font-semibold text-gray-700\">\n            {selectedSectionId ? `Assessments for Section ${sectionName}` : 'Select a section to view assessments'}\n        </h2>\n        {(isPC || sectionsForDropdown.length > 0) && (\n          <button onClick={() => setCreateModalOpen(true)} className=\"bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg disabled:bg-indigo-300 disabled:cursor-not-allowed\" disabled={!selectedSectionId} title={!selectedSectionId ? \"Please select a section first\" : \"Create a new assessment\"}>\n            Create Assessment\n          </button>\n        )}\n      </div>\n      \n      <div className=\"space-y-4\">\n        {assessments.map(assessment => {\n          const totalMaxMarks = assessment.questions.reduce((sum, q) => sum + q.maxMarks, 0);\n          const hasMarks = data.marks.some(m => m.assessmentId === assessment.id);\n          return (\n            <div key={assessment.id} className=\"bg-gray-50 p-4 rounded-lg flex justify-between items-center border border-gray-200\">\n              <div>\n                <p className=\"font-semibold text-gray-800 flex items-center\">\n                  {assessment.name}\n                  {hasMarks && (<span className=\"ml-2 text-xs font-semibold bg-green-100 text-green-800 px-2 py-0.5 rounded-full\">✓ Marks Uploaded</span>)}\n                </p>\n                <p className=\"text-sm text-gray-500\">{assessment.type} | Max Marks: {totalMaxMarks}</p>\n              </div>\n              <div className=\"space-x-4\">\n                <button onClick={() => setSelectedAssessmentId(assessment.id)} className=\"text-indigo-600 hover:text-indigo-800 font-semibold\">\n                  Manage Questions\n                </button>\n                {isPC && (<button onClick={() => handleDeleteAssessment(assessment.id)} className=\"text-red-600 hover:text-red-800 font-semibold\">Delete</button>)}\n              </div>\n            </div>\n          )\n        })}\n        {assessments.length === 0 && selectedSectionId && <p className=\"text-gray-500 text-center py-4\">No assessments found for this section.</p>}\n      </div>\n      {isCreateModalOpen && selectedSectionId && (\n        <CreateAssessmentModal sectionId={selectedSectionId} onClose={() => setCreateModalOpen(false)} />\n      )}\n    </div>\n  );\n};\n\nexport default ManageCourseAssessments;",
  "components/AssessmentDetails.tsx": "/**\n * @file AssessmentDetails.tsx\n * @description\n * This component is the detailed management view for a single assessment. It's one of the most\n * complex components in the application, handling multiple user interactions and data operations.\n *\n * What it does:\n * 1.  **Displays Assessment Info**: Shows the name of the assessment.\n * 2.  **Manages Questions**: \n *     - Allows users to add, edit, and delete questions for the assessment.\n *     - Allows bulk-uploading questions from an Excel file.\n * 3.  **CO Mapping**: Provides a table where each question can be mapped to one or more\n *     Course Outcomes (COs) using checkboxes.\n * 4.  **Manages Student Marks**:\n *     - Provides a \"Download Template\" button that generates an Excel file with the correct\n *       student list and question columns, ready for filling in marks.\n *     - Provides an \"Upload Marks\" button that parses a filled-in Excel template and saves\n *       the student scores to the application's state.\n * 5.  **Draft State**: Like other management screens, it uses a \"draft state\" for all question\n *     and CO mapping changes. These changes are only saved when the user clicks \"Save Changes\"\n *     in the `SaveBar`. Note: Mark uploads are saved immediately.\n */\n\nimport React, { useState, useMemo, useEffect } from 'react';\nimport { Assessment, AssessmentQuestion, Mark, MarkScore, Course } from '../types';\nimport { useAppContext } from '../hooks/useAppContext';\nimport ExcelUploader from './ExcelUploader';\nimport { PlusCircle, Trash2, Download, ChevronUp, Edit } from './Icons';\nimport SaveBar from './SaveBar';\nimport ConfirmationModal from './ConfirmationModal';\n\n// This line tells our code that a library called `XLSX` will be available globally.\n// This library is loaded from a `<script>` tag in `index.html`.\ndeclare const XLSX: any;\n\n// This defines the \"props\" or properties that this component accepts.\ninterface AssessmentDetailsProps {\n  assessmentId: string; // The ID of the assessment we are managing.\n  onBack: () => void; // A function to call to go back to the assessment list.\n  course: Course; // The parent course, needed for context like finding COs.\n}\n\nconst AssessmentDetails: React.FC<AssessmentDetailsProps> = ({ assessmentId, onBack, course }) => {\n    // Get all the data and tools from our \"magic backpack\".\n    const { data, setData, currentUser } = useAppContext();\n    const canManage = currentUser?.role === 'Teacher' || currentUser?.role === 'Program Co-ordinator';\n    \n    // State for the \"Are you sure?\" confirmation popup.\n    const [confirmation, setConfirmation] = useState<{\n        isOpen: boolean; title: string; message: string; onConfirm: () => void;\n    } | null>(null);\n\n    // `useMemo` is a \"smart calculator\" that finds the full assessment object from our data.\n    const assessment = useMemo(() => data.assessments.find(a => a.id === assessmentId), [data.assessments, assessmentId]);\n\n    // --- State Management for Drafts ---\n    // `draftQuestions` is the temporary copy of questions we make changes to.\n    const [draftQuestions, setDraftQuestions] = useState<AssessmentQuestion[]>([]);\n    // `initialQuestions` is the saved version, used for comparison to see if there are unsaved changes.\n    const [initialQuestions, setInitialQuestions] = useState<AssessmentQuestion[]>([]);\n    // State for handling inline editing of a question.\n    const [editingQuestion, setEditingQuestion] = useState<{ originalQ: string; name: string; maxMarks: number } | null>(null);\n\n    // This `useEffect` hook loads the assessment's questions into our draft states when the component first appears.\n    useEffect(() => {\n        if (assessment) {\n            setDraftQuestions(assessment.questions);\n            setInitialQuestions(assessment.questions);\n        }\n    }, [assessment]);\n\n    // `isDirty` checks if there are unsaved changes by comparing the draft to the initial state.\n    const isDirty = useMemo(() => JSON.stringify(initialQuestions) !== JSON.stringify(draftQuestions), [initialQuestions, draftQuestions]);\n\n    // This `useMemo` automatically calculates the name for the next question (e.g., \"Q3\").\n    const nextQName = useMemo(() => {\n        if (!draftQuestions) return 'Q1';\n        const highestNum = draftQuestions.reduce((max, q) => {\n            const num = parseInt(q.q.replace('Q', ''), 10);\n            return !isNaN(num) && num > max ? num : max;\n        }, 0);\n        return `Q${highestNum + 1}`;\n    }, [draftQuestions]);\n    \n    // State for the \"Add New Question\" form fields.\n    const [newQName, setNewQName] = useState(nextQName);\n    const [newQMaxMarks, setNewQMaxMarks] = useState(10);\n    \n    // This effect keeps the `newQName` field up-to-date.\n    useEffect(() => {\n        setNewQName(nextQName);\n    }, [nextQName]);\n    \n    // Safety check: if the assessment or course can't be found, show an error.\n    if (!assessment || !course) {\n        return (\n            <div>\n                <p className=\"text-red-500\">Assessment or associated course not found.</p>\n                <button onClick={onBack} className=\"mt-4 flex items-center text-indigo-600 hover:text-indigo-800\">\n                    <svg className=\"w-5 h-5 mr-2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M10 19l-7-7m0 0l7-7m-7 7h18\"></path></svg>\n                    Back to Assessments\n                </button>\n            </div>\n        );\n    }\n    \n    // Get the list of COs that belong to this course, which we'll need for mapping.\n    const courseOutcomes = data.courseOutcomes.filter(co => co.courseId === course.id);\n\n    // This function runs when the \"Download Template\" button is clicked.\n    const handleDownloadTemplate = () => {\n        // Find all students who are enrolled in this assessment's specific section.\n        const studentIdsForSection = new Set(data.enrollments.filter(e => e.sectionId === assessment.sectionId).map(e => e.studentId));\n        const activeEnrolledStudents = data.students.filter(s => s.status === 'Active' && studentIdsForSection.has(s.id)).sort((a, b) => a.id.localeCompare(b.id));\n\n        // Get the headers for the questions from our draft state.\n        const questionHeaders = draftQuestions.map(q => q.q).sort((a, b) => parseInt(a.substring(1)) - parseInt(b.substring(1)));\n\n        // Create the data for the Excel sheet, with one row per student.\n        const templateData = activeEnrolledStudents.map(student => {\n            const studentRow: { [key: string]: string | number } = { 'Student ID': student.id, 'Student Name': student.name };\n            questionHeaders.forEach(header => { studentRow[header] = ''; }); // Leave mark columns empty.\n            return studentRow;\n        });\n        \n        // Use the SheetJS library (`XLSX`) to create and download the Excel file.\n        try {\n            if (typeof XLSX === 'undefined') { alert('Excel library (SheetJS) is not loaded.'); return; }\n            const worksheet = XLSX.utils.json_to_sheet(templateData);\n            const workbook = XLSX.utils.book_new();\n            XLSX.utils.book_append_sheet(workbook, worksheet, 'Marks Template');\n            const fileName = `Marks-Template-${course?.code || 'Course'}-${assessment.name}.xlsx`.replace(/\\s+/g, '_');\n            XLSX.writeFile(workbook, fileName);\n        } catch (error) {\n            console.error(\"Error generating Excel template:\", error);\n            alert(\"Failed to generate the Excel template.\");\n        }\n    };\n\n    // This function is called by the \"Upload Questions\" ExcelUploader.\n    const handleQuestionsUpload = (uploadedData: { q: string; maxMarks: string | number }[]) => {\n      // Convert the uploaded data into proper `AssessmentQuestion` objects.\n      const newQuestions: AssessmentQuestion[] = uploadedData\n          .filter(row => row.q && row.maxMarks && !isNaN(Number(row.maxMarks)) && Number(row.maxMarks) > 0)\n          .map(row => ({ q: String(row.q).trim(), maxMarks: Number(row.maxMarks), coIds: [] }));\n\n      // Add the new questions to our draft, making sure not to add duplicates.\n      setDraftQuestions(prevDraft => {\n        const existingQNames = new Set(prevDraft.map(q => q.q.toLowerCase()));\n        const uniqueNewQs = newQuestions.filter(nq => !existingQNames.has(nq.q.toLowerCase()));\n        alert(`${uniqueNewQs.length} new questions staged. ${newQuestions.length - uniqueNewQs.length} duplicates ignored. Click 'Save Changes' to commit.`);\n        return [...prevDraft, ...uniqueNewQs];\n      });\n    };\n\n    // This function is called by the \"Upload Marks\" ExcelUploader.\n    const handleMarksUpload = (uploadedData: any[]) => {\n      const studentIdsInSection = new Set(data.enrollments.filter(e => e.sectionId === assessment.sectionId).map(e => e.studentId));\n\n      // This update happens immediately, not in a draft state.\n      setData(prev => {\n          let updatedMarks = [...prev.marks]; // Make a copy of the marks data.\n\n          // Go through each row in the uploaded Excel file.\n          uploadedData.forEach(row => {\n              const studentIdKey = Object.keys(row).find(key => key.toLowerCase().includes('id'));\n              if (!studentIdKey) return; // Skip if no student ID column is found.\n              const studentId = String(row[studentIdKey]);\n              if (!studentId || !studentIdsInSection.has(studentId)) return; // Skip if the student isn't in this section.\n\n              // Find or create a mark entry for this student and this assessment.\n              let markEntryIndex = updatedMarks.findIndex(m => m.studentId === studentId && m.assessmentId === assessment.id);\n              let studentMarkEntry: Mark = markEntryIndex === -1\n                  ? { studentId, assessmentId: assessment.id, scores: [] }\n                  : { ...updatedMarks[markEntryIndex], scores: [...updatedMarks[markEntryIndex].scores] };\n\n              // Go through each column (e.g., \"Q1\", \"Q2\") in the row.\n              Object.keys(row).forEach(qName => {\n                  if (draftQuestions.some(q => q.q === qName)) { // If this column is a valid question...\n                      const score: MarkScore = { q: qName, marks: Number(row[qName]) };\n                      const scoreIndex = studentMarkEntry.scores.findIndex(s => s.q === qName);\n                      if (scoreIndex > -1) studentMarkEntry.scores[scoreIndex] = score; // Update existing score.\n                      else studentMarkEntry.scores.push(score); // Add new score.\n                  }\n              });\n\n              // Put the updated mark entry back into our list.\n              if (markEntryIndex === -1) updatedMarks.push(studentMarkEntry);\n              else updatedMarks[markEntryIndex] = studentMarkEntry;\n          });\n          // Return the new state for the whole application.\n          return { ...prev, marks: updatedMarks };\n      });\n      alert(`Marks processed for ${uploadedData.length} students.`);\n    };\n\n    // --- Handlers for Adding/Editing/Removing Questions in the Draft ---\n    const handleAddQuestion = () => {\n        const newQuestion: AssessmentQuestion = { q: newQName.trim(), maxMarks: Number(newQMaxMarks), coIds: [] };\n        setDraftQuestions(prev => [...prev, newQuestion]);\n        setNewQMaxMarks(10);\n    };\n\n    const handleRemoveQuestion = (questionNameToDelete: string) => {\n        setConfirmation({\n            isOpen: true, title: 'Delete Question',\n            message: `Are you sure you want to delete this question? All student marks for this question will also be removed. This change will be applied when you save.`,\n            onConfirm: () => {\n                setDraftQuestions(prev => prev.filter(q => q.q !== questionNameToDelete));\n                setConfirmation(null);\n            },\n        });\n    };\n    \n    const handleCoMappingChange = (qName: string, coId: string, isChecked: boolean) => {\n      setDraftQuestions(prevQs => prevQs.map(q => \n          q.q === qName ? { ...q, coIds: isChecked ? [...q.coIds, coId] : q.coIds.filter(id => id !== coId) } : q\n      ));\n    };\n\n    const handleEditStart = (q: AssessmentQuestion) => setEditingQuestion({ originalQ: q.q, name: q.q, maxMarks: q.maxMarks });\n    const handleEditCancel = () => setEditingQuestion(null);\n    const handleEditSave = () => {\n      if (!editingQuestion) return;\n      const { originalQ, name: newName, maxMarks } = editingQuestion;\n      setDraftQuestions(prev => prev.map(q => q.q === originalQ ? { ...q, q: newName.trim(), maxMarks } : q));\n      setEditingQuestion(null);\n    };\n\n    // --- Handlers for the SaveBar ---\n    const handleSave = () => {\n        setData(prev => {\n            // Update the assessment in the main data with our draft questions.\n            const updatedAssessments = prev.assessments.map(a => \n                a.id === assessment.id ? { ...a, questions: draftQuestions } : a\n            );\n            \n            // Also, if any questions were deleted, we need to remove their scores from the marks data.\n            const oldQuestionNames = new Set(initialQuestions.map(q => q.q));\n            const newQuestionNames = new Set(draftQuestions.map(q => q.q));\n            const deletedQuestionNames = [...oldQuestionNames].filter(name => !newQuestionNames.has(name));\n            const updatedMarks = prev.marks.map(mark => {\n                if (mark.assessmentId === assessment.id) {\n                    const updatedScores = mark.scores.filter(score => !deletedQuestionNames.includes(score.q));\n                    return { ...mark, scores: updatedScores };\n                }\n                return mark;\n            }).filter(mark => mark.scores.length > 0 || mark.assessmentId !== assessment.id);\n\n            return { ...prev, assessments: updatedAssessments, marks: updatedMarks };\n        });\n        setInitialQuestions(draftQuestions); // Reset the \"dirty\" check.\n        alert(\"Questions and CO mappings saved!\");\n    };\n\n    const handleCancel = () => {\n        setDraftQuestions(initialQuestions); // Discard changes.\n        setEditingQuestion(null);\n    };\n\n    return (\n        <div className=\"space-y-6 pb-20\">\n            {/* Header section */}\n            <div className=\"flex justify-between items-center\">\n                <h2 className=\"text-2xl font-bold text-gray-800\">Manage: {assessment.name}</h2>\n                <button onClick={onBack} className=\"flex items-center px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-semibold\">\n                    <ChevronUp className=\"w-5 h-5 mr-2\" />\n                    Back to List\n                </button>\n            </div>\n            \n            {/* Marks Upload Section */}\n            <div className=\"bg-gray-50 border border-gray-200 p-4 rounded-lg\">\n                <h3 className=\"text-lg font-semibold text-gray-700 mb-4\">Upload Student Marks</h3>\n                 <div className=\"flex items-start gap-4\">\n                    <button type=\"button\" onClick={handleDownloadTemplate} className=\"px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 flex items-center gap-2\">\n                        <Download className=\"w-5 h-5\" /> Download Template\n                    </button>\n                    <ExcelUploader<any> onFileUpload={handleMarksUpload} label=\"Upload Marks\" format=\"cols: id, name, Q1, Q2...\" />\n                </div>\n            </div>\n\n            {/* Questions Management Section */}\n            <div className=\"bg-gray-50 border border-gray-200 p-4 rounded-lg\">\n                 {canManage && (\n                    <div className=\"pb-4 mb-4 border-b border-gray-200\">\n                        <h4 className=\"text-lg font-semibold text-gray-700 mb-2\">Bulk Upload Questions</h4>\n                        <ExcelUploader<{ q: string; maxMarks: string | number }> onFileUpload={handleQuestionsUpload} label=\"Upload Questions\" format=\"columns: q, maxMarks\" />\n                    </div>\n                )}\n                <h3 className=\"text-lg font-semibold text-gray-700 mb-4\">Manage Questions & CO Mapping</h3>\n                {/* The main table for questions and CO mapping */}\n                <div className=\"overflow-x-auto\">\n                    <table className=\"min-w-full divide-y divide-gray-200\">\n                    <thead className=\"bg-gray-100\">\n                        <tr>\n                            <th className=\"px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase\">Question</th>\n                            <th className=\"px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase\">Max Marks</th>\n                            {courseOutcomes.map(co => (\n                                <th key={co.id} className=\"px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase\">{co.number}</th>\n                            ))}\n                            {canManage && <th className=\"px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase\">Actions</th>}\n                        </tr>\n                    </thead>\n                    <tbody className=\"bg-white divide-y divide-gray-200\">\n                        {/* Loop through draft questions to display them */}\n                        {draftQuestions.map(q => (\n                            <tr key={q.q}>\n                              {editingQuestion?.originalQ === q.q ? (\n                                <> {/* Inline editing UI */}\n                                  <td className=\"px-4 py-2\"><input type=\"text\" value={editingQuestion.name} onChange={e => setEditingQuestion({...editingQuestion, name: e.target.value})} className=\"w-full p-2 border rounded-md\" /></td>\n                                  <td className=\"px-4 py-2\"><input type=\"number\" value={editingQuestion.maxMarks} onChange={e => setEditingQuestion({...editingQuestion, maxMarks: Number(e.target.value)})} className=\"w-24 p-2 border rounded-md\" /></td>\n                                  <td colSpan={courseOutcomes.length}></td>\n                                  <td className=\"px-4 py-2 text-right whitespace-nowrap\">\n                                      <button onClick={handleEditSave} className=\"text-green-600 font-semibold mr-2\">Apply</button>\n                                      <button onClick={handleEditCancel} className=\"text-gray-600\">Cancel</button>\n                                  </td>\n                                </>\n                              ) : (\n                                <> {/* Standard display UI */}\n                                  <td className=\"px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900\">{q.q}</td>\n                                  <td className=\"px-4 py-2 whitespace-nowrap text-sm text-gray-600\">{q.maxMarks}</td>\n                                  {courseOutcomes.map(co => (\n                                      <td key={co.id} className=\"px-4 py-2 text-center\">\n                                          <input type=\"checkbox\" checked={q.coIds.includes(co.id)} onChange={(e) => canManage && handleCoMappingChange(q.q, co.id, e.target.checked)} disabled={!canManage} className=\"h-4 w-4 text-indigo-600 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500 disabled:opacity-50\" />\n                                      </td>\n                                  ))}\n                                  {canManage && (\n                                      <td className=\"px-4 py-2 text-right\">\n                                          <button onClick={() => handleEditStart(q)} aria-label={`Edit question ${q.q}`} className=\"text-indigo-600 hover:text-indigo-800 p-1 mr-1\"><Edit className=\"w-5 h-5\" /></button>\n                                          <button onClick={() => handleRemoveQuestion(q.q)} aria-label={`Delete question ${q.q}`} className=\"text-red-600 hover:text-red-800 p-1\"><Trash2 className=\"w-5 h-5\" /></button>\n                                      </td>\n                                  )}\n                                </>\n                              )}\n                            </tr>\n                        ))}\n                        {/* \"Add New Question\" form row */}\n                        {canManage && !editingQuestion && (\n                            <tr className=\"bg-gray-50\">\n                                <td className=\"px-4 py-2\"><input type=\"text\" value={newQName} readOnly className=\"w-full p-2 border border-gray-300 rounded-md bg-gray-100 text-gray-500 cursor-not-allowed focus:ring-0 focus:border-gray-300\" /></td>\n                                <td className=\"px-4 py-2\"><input type=\"number\" value={newQMaxMarks} onChange={e => setNewQMaxMarks(Number(e.target.value))} className=\"w-24 p-2 border border-gray-300 rounded-md bg-white text-gray-900\" /></td>\n                                <td colSpan={courseOutcomes.length}></td>\n                                <td className=\"px-4 py-2 text-right\"><button onClick={handleAddQuestion} aria-label=\"Add new question\" className=\"bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700\"><PlusCircle className=\"w-5 h-5\" /></button></td>\n                            </tr>\n                        )}\n                    </tbody>\n                    </table>\n                </div>\n            </div>\n            {/* The SaveBar and ConfirmationModal */}\n            <SaveBar isDirty={isDirty} onSave={handleSave} onCancel={handleCancel} />\n            {confirmation && (<ConfirmationModal isOpen={confirmation.isOpen} title={confirmation.title} message={confirmation.message} onConfirm={confirmation.onConfirm} onClose={() => setConfirmation(null)}/>)}\n        </div>\n    );\n};\n\nexport default AssessmentDetails;",
  "components/CoPoMappingMatrix.tsx": "/**\n * @file CoPoMappingMatrix.tsx\n * @description\n * This component is the \"CO-PO Mapping\" tab within the `CourseDetail` page. It's responsible\n * for displaying and managing the relationships between a course's Course Outcomes (COs)\n * and the program's Program Outcomes (POs).\n *\n * What it does:\n * 1.  **Displays a Matrix**: It shows a grid or table where the rows are the COs for the\n *     current course, and the columns are the POs for the program.\n * 2.  **Manages Mappings**: In each cell of the grid, it displays a dropdown (0-3) that\n *     represents the strength of the mapping between that CO and PO (0 means no mapping).\n * 3.  **Handles Data Transformation**: The mapping data in `mockData.json` is stored as a flat\n *     list of connections (e.g., `{ courseId, coId, poId, level }`). This component transforms\n *     that list into a nested object structure that's easier for the UI to read (like a 2D array).\n * 4.  **Draft State**: It uses a \"draft state\" pattern. When a user changes a mapping level\n *     in a dropdown, the change is stored in a temporary \"draft\". The `SaveBar` appears,\n *     allowing the user to save all changes at once or cancel them.\n * 5.  **Saves Data**: When saving, it transforms the nested object back into a flat list\n *     to update the main application data.\n */\n\nimport React, { useState, useMemo, useEffect } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { CoPoMapping, CoPoMap } from '../types';\nimport { useAppContext } from '../hooks/useAppContext';\nimport SaveBar from './SaveBar';\n\n\nconst CoPoMappingMatrix: React.FC = () => {\n  // Get the `courseId` from the URL to know which course we're working with.\n  const { courseId } = useParams<{ courseId: string }>();\n  // Get data, tools, and user info from the \"magic backpack\".\n  const { data, setData, currentUser } = useAppContext();\n  \n  // Check if the current user has permission to edit the mappings.\n  const canManage = currentUser?.role === 'Teacher' || currentUser?.role === 'Program Co-ordinator';\n\n  // `useMemo` is a \"smart calculator\" that gets all the relevant COs, POs, and existing mappings for this course.\n  const { courseOutcomes, programOutcomes, initialMapArray } = useMemo(() => {\n    const course = data.courses.find(c => c.id === courseId);\n    return {\n      courseOutcomes: data.courseOutcomes.filter(co => co.courseId === courseId),\n      programOutcomes: data.programOutcomes.filter(po => po.programId === course?.programId),\n      initialMapArray: data.coPoMapping.filter(m => m.courseId === courseId),\n    };\n  }, [courseId, data]);\n  \n  // --- State Management for Drafts ---\n  // `draftMapping` is the nested object that backs our UI. It looks like: { \"co_id_1\": { \"po_id_1\": 3 } }\n  const [draftMapping, setDraftMapping] = useState<CoPoMap>({});\n  // `initialMapping` is the saved version, used for checking if there are unsaved changes.\n  const [initialMapping, setInitialMapping] = useState<CoPoMap>({});\n\n  // This `useEffect` hook performs the initial data transformation.\n  // It runs once when the component loads, converting the `initialMapArray` (a flat list)\n  // into the `CoPoMap` structure (a nested object) for our state.\n  useEffect(() => {\n    const map: CoPoMap = {};\n    // First, create an entry for every CO.\n    for (const co of courseOutcomes) {\n      map[co.id] = {};\n    }\n    // Then, fill in the mapping levels from the flat array.\n    for (const m of initialMapArray) {\n      if (map[m.coId]) {\n        map[m.coId][m.poId] = m.level;\n      }\n    }\n    setDraftMapping(map); // Set both draft and initial states to this transformed data.\n    setInitialMapping(map);\n  }, [courseOutcomes, initialMapArray]);\n\n  // `isDirty` checks for unsaved changes by comparing the text versions of the draft and initial mappings.\n  const isDirty = useMemo(() => JSON.stringify(draftMapping) !== JSON.stringify(initialMapping), [draftMapping, initialMapping]);\n\n  // This function runs every time a user changes a value in one of the dropdowns.\n  const handleMappingChange = (coId: string, poId: string, value: string) => {\n    const level = parseInt(value, 10);\n    // Update the `draftMapping` state with the new level.\n    setDraftMapping(prev => ({\n      ...prev,\n      [coId]: {\n        ...prev[coId],\n        [poId]: level\n      }\n    }));\n  };\n\n  // This function runs when the \"Save Changes\" button is clicked in the SaveBar.\n  const handleSave = () => {\n    if (!courseId) return;\n    \n    // --- Data Transformation (Reverse) ---\n    // Here, we convert our nested `draftMapping` object back into a flat array,\n    // which is the format our main application data expects.\n    const newMappingArray: CoPoMapping[] = [];\n    Object.keys(draftMapping).forEach(coId => {\n      Object.keys(draftMapping[coId]).forEach(poId => {\n        const level = draftMapping[coId][poId];\n        if (level > 0) { // We only save mappings with a level greater than 0.\n          newMappingArray.push({ courseId, coId, poId, level });\n        }\n      });\n    });\n\n    // Update the main application data in the \"magic backpack\".\n    setData(prev => ({\n      ...prev,\n      coPoMapping: [\n        ...prev.coPoMapping.filter(m => m.courseId !== courseId), // Remove all old mappings for this course.\n        ...newMappingArray // Add the new mappings from our draft.\n      ]\n    }));\n    \n    // The draft is now the new saved state.\n    setInitialMapping(draftMapping);\n    alert(\"Mapping saved successfully!\");\n  };\n\n  // This function runs when the \"Cancel\" button is clicked. It discards all changes.\n  const handleCancel = () => {\n    setDraftMapping(initialMapping);\n  };\n\n  return (\n    <div className=\"space-y-6 pb-20\">\n      <h2 className=\"text-xl font-semibold text-gray-700\">CO-PO Mapping Matrix</h2>\n      <div className=\"overflow-x-auto\">\n        <table className=\"min-w-full border-collapse border border-gray-300\">\n          <thead className=\"bg-gray-50\">\n            <tr>\n              <th className=\"border border-gray-300 p-2 text-xs font-medium text-gray-500 uppercase\">CO</th>\n              {programOutcomes.map(po => (\n                <th key={po.id} className=\"border border-gray-300 p-2 text-xs font-medium text-gray-500 uppercase\" title={po.description}>\n                  {po.number}\n                </th>\n              ))}\n            </tr>\n          </thead>\n          <tbody>\n            {courseOutcomes.map(co => (\n              <tr key={co.id} className=\"bg-white hover:bg-gray-50\">\n                <td className=\"border border-gray-300 p-2 text-sm font-medium text-gray-900\" title={co.description}>\n                  {co.number}\n                </td>\n                {programOutcomes.map(po => (\n                  <td key={po.id} className=\"border border-gray-300 p-1\">\n                    <select\n                      value={draftMapping[co.id]?.[po.id] || 0}\n                      onChange={(e) => handleMappingChange(co.id, po.id, e.target.value)}\n                      className=\"w-full bg-white text-gray-900 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 disabled:bg-gray-100\"\n                      disabled={!canManage}\n                    >\n                      <option value=\"0\">-</option>\n                      <option value=\"1\">1</option>\n                      <option value=\"2\">2</option>\n                      <option value=\"3\">3</option>\n                    </select>\n                  </td>\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n      \n      {/* The SaveBar only appears if `isDirty` is true. */}\n      <SaveBar isDirty={isDirty} onSave={handleSave} onCancel={handleCancel} />\n    </div>\n  );\n};\n\nexport default CoPoMappingMatrix;",
  "pages/ProgramOutcomesList.tsx": "/**\n * @file ProgramOutcomesList.tsx\n * @description\n * This file defines the `ProgramOutcomesList` component, which is the main page for managing\n * Program Outcomes (POs) and viewing PO attainment data.\n *\n * What it does:\n * 1.  **Displays POs**: It shows a list of all Program Outcomes defined for the currently\n *     selected program.\n * 2.  **Manages POs (Role-based)**: For authorized users (Admins, PCs), it provides buttons to\n *     \"Add New PO\" (which opens a modal) and \"Upload POs\" from an Excel file. It also\n *     allows deleting existing POs.\n * 3.  **Contains Dashboards**: This page acts as a container for two very important and complex\n *     dashboard components:\n *     - `POAttainmentDashboard`: Calculates and displays the final attainment for each PO.\n *     - `CoursePoLinkageDashboard`: Shows how strongly each course contributes to each PO.\n * 4.  **Manages Dashboard Settings**: It manages the \"draft state\" for the settings on the\n *     `POAttainmentDashboard` (like the direct/indirect weights). When a user changes these\n *     settings, the `SaveBar` appears, allowing them to save or cancel the changes for their\n *     current session.\n */\n\nimport React, { useState, useMemo, useEffect } from 'react';\nimport { ProgramOutcome } from '../types';\nimport ExcelUploader from '../components/ExcelUploader';\nimport { useAppContext } from '../hooks/useAppContext';\nimport POAttainmentDashboard from '../components/POAttainmentDashboard';\nimport { Trash2 } from '../components/Icons';\nimport AddProgramOutcomeModal from '../components/AddProgramOutcomeModal';\nimport SaveBar from '../components/SaveBar';\nimport CoursePoLinkageDashboard from '../components/CoursePoLinkageDashboard';\n\nconst ProgramOutcomesList: React.FC = () => {\n  // We get our app's data, tools, and the current user from the \"magic backpack\".\n  // We need `currentUser` to check permissions.\n  const { selectedProgram, data, setData, currentUser } = useAppContext();\n  \n  // A piece of memory to control whether the \"Add New PO\" popup is open.\n  const [isModalOpen, setModalOpen] = useState(false);\n\n  // A boolean to check if the current user has permission to manage POs.\n  const canManagePOs = currentUser?.role === 'Admin' || currentUser?.role === 'Program Co-ordinator';\n  \n  // `useMemo` is a smart calculator that gets the POs and relevant courses for the selected program.\n  const { programOutcomes, coursesForProgram } = useMemo(() => {\n    const outcomes = data.programOutcomes.filter(po => po.programId === selectedProgram?.id);\n    const courses = data.courses.filter(c => c.programId === selectedProgram?.id && c.status !== 'Future');\n    return { programOutcomes: outcomes, coursesForProgram: courses };\n  }, [data.programOutcomes, data.courses, selectedProgram?.id]);\n\n  // --- State Management for the Dashboard's Draftable Settings ---\n  // `originalState` holds the saved version of the dashboard settings.\n  const [originalState, setOriginalState] = useState({ weights: { direct: 90, indirect: 10 }, indirectAttainment: {} as {[poId: string]: string} });\n  // `draftState` holds the temporary changes the user is making to the settings.\n  const [draftState, setDraftState] = useState(originalState);\n  \n  // `useEffect` runs this code whenever the selected program changes. It resets the dashboard settings.\n  useEffect(() => {\n    const initialState = { weights: { direct: 90, indirect: 10 }, indirectAttainment: {} };\n    setDraftState(initialState);\n    setOriginalState(initialState);\n  }, [selectedProgram?.id]);\n\n  // `isDirty` checks if there are unsaved changes by comparing the draft and original states.\n  const isDirty = useMemo(() => JSON.stringify(originalState) !== JSON.stringify(draftState), [originalState, draftState]);\n\n  // This runs when \"Save Changes\" is clicked on the SaveBar.\n  const handleSave = () => {\n    // In our mock app, we just \"commit\" the draft to be the new original state for this session.\n    setOriginalState(draftState);\n    alert(\"Attainment values have been saved for this session.\");\n  };\n\n  // This runs when \"Cancel\" is clicked. It discards the changes.\n  const handleCancel = () => {\n    setDraftState(originalState);\n  };\n\n  // This is called by the ExcelUploader when a file is parsed.\n  const handleExcelUpload = (uploadedData: { number: string; description: string }[]) => {\n    if (!selectedProgram) return;\n    // Convert the Excel rows into ProgramOutcome objects.\n    const newPOs: ProgramOutcome[] = uploadedData\n      .filter(row => row.number && row.description)\n      .map((row, i) => ({\n        id: `po_excel_${Date.now()}_${i}`,\n        programId: selectedProgram.id,\n        number: row.number,\n        description: row.description\n    }));\n    // Add the new POs to our main application data.\n    setData(prev => ({ ...prev, programOutcomes: [...prev.programOutcomes, ...newPOs] }));\n    alert(`${newPOs.length} POs uploaded successfully!`);\n  };\n  \n  // This runs when the trash can icon next to a PO is clicked.\n  const handleDeletePo = (poId: string) => {\n    if (window.confirm(\"Are you sure you want to delete this Program Outcome?\")) {\n        // It removes the PO from the main application data.\n        setData(prev => ({\n            ...prev,\n            programOutcomes: prev.programOutcomes.filter(po => po.id !== poId)\n        }));\n    }\n  }\n\n  return (\n    // `pb-20` adds padding at the bottom so the SaveBar doesn't cover content.\n    <div className=\"space-y-6 pb-20\">\n      <div className=\"flex justify-between items-start\">\n        <h1 className=\"text-3xl font-bold text-gray-800\">Program Outcomes (POs)</h1>\n        {/* The Add/Upload buttons are now only shown to users with permission. */}\n        {canManagePOs && (\n          <div className=\"flex items-start gap-4\">\n              <ExcelUploader<{ number: string; description: string }>\n                  onFileUpload={handleExcelUpload}\n                  label=\"Upload POs\"\n                  format=\"columns: number, description\"\n              />\n              <button onClick={() => setModalOpen(true)} className=\"bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg\">\n                  Add New PO\n              </button>\n          </div>\n        )}\n      </div>\n      \n      {/* The list of current POs. */}\n      <div className=\"bg-white p-6 rounded-lg shadow-md\">\n        <h2 className=\"text-xl font-semibold mb-4 text-gray-700\">Current POs</h2>\n         <ul className=\"space-y-3\">\n            {programOutcomes.map(po => (\n                <li key={po.id} className=\"p-4 bg-gray-100 rounded-lg flex justify-between items-center\">\n                    <div>\n                        <span className=\"font-bold text-gray-800\">{po.number}:</span>\n                        <span className=\"ml-2 text-gray-600\">{po.description}</span>\n                    </div>\n                    {/* The Delete button is also only shown to users with permission. */}\n                    {canManagePOs && (\n                      <button onClick={() => handleDeletePo(po.id)} className=\"text-red-600 hover:text-red-800\">\n                          <Trash2 className=\"w-5 h-5\" />\n                      </button>\n                    )}\n                </li>\n            ))}\n            {programOutcomes.length === 0 && <p className=\"text-gray-500 text-center py-4\">No Program Outcomes defined for this program yet.</p>}\n        </ul>\n      </div>\n      \n      {/* The main PO Attainment Dashboard component.\n          We pass it the draft state and a function to update the draft state (`onStateChange`).\n          This is called \"lifting state up\", where the parent component manages the state for the child. */}\n      <POAttainmentDashboard \n        programOutcomes={programOutcomes}\n        draftState={draftState}\n        onStateChange={setDraftState}\n        selectedProgram={selectedProgram}\n      />\n\n      {/* The second dashboard, which shows how courses link to POs. */}\n      <CoursePoLinkageDashboard \n        programOutcomes={programOutcomes}\n        courses={coursesForProgram}\n      />\n      \n      {/* The modal for adding a new PO is only shown if `isModalOpen` is true. */}\n      {isModalOpen && (\n        <AddProgramOutcomeModal onClose={() => setModalOpen(false)} />\n      )}\n      \n      {/* The SaveBar only appears if `isDirty` is true. */}\n      <SaveBar isDirty={isDirty} onSave={handleSave} onCancel={handleCancel} />\n    </div>\n  );\n};\n\nexport default ProgramOutcomesList;",
  "components/POAttainmentDashboard.tsx": "/**\n * @file POAttainmentDashboard.tsx\n * @description\n * This is one of the most important and complex components in the application. It's the dashboard\n * on the `ProgramOutcomesList` page that calculates and displays the attainment levels for each\n * Program Outcome (PO).\n *\n * It consists of three main parts:\n * 1.  **Direct Attainment (Calculated)**: This is the most complex part. It calculates the PO\n *     attainment based on actual student performance in courses. It does this by:\n *     a. Calculating the attainment level for every single Course Outcome (CO) across all\n *        relevant courses in the selected program and batch.\n *     b. Using the CO-PO Mapping Matrix to calculate a weighted average, which becomes the\n *        \"Direct Attainment\" for each PO.\n * 2.  **Indirect Attainment (Manual Input)**: This provides a row of input fields where a user\n *     can manually enter attainment values, which are typically gathered from sources like\n *     surveys, employer feedback, etc.\n * 3.  **Overall Attainment (Calculated)**: This calculates the final PO attainment by combining\n *     the Direct and Indirect values using a weighted average, which the user can also adjust.\n */\n\nimport React, { useMemo } from 'react';\nimport { ProgramOutcome, Program } from '../types';\nimport { useAppContext } from '../hooks/useAppContext';\n\n// Defines the \"shape\" of the settings this dashboard manages (weights and indirect values).\ninterface DashboardState {\n    weights: { direct: number; indirect: number; };\n    indirectAttainment: { [poId: string]: string; };\n}\n// Defines the \"props\" or properties this component accepts from its parent.\ninterface POAttainmentDashboardProps {\n  programOutcomes: ProgramOutcome[];\n  draftState: DashboardState;\n  onStateChange: (newState: DashboardState) => void;\n  selectedProgram: Program | null;\n}\n\nconst POAttainmentDashboard: React.FC<POAttainmentDashboardProps> = ({ programOutcomes, draftState, onStateChange, selectedProgram }) => {\n  // We get our app's data and the selected batch from the \"magic backpack\".\n  const { data, selectedBatch } = useAppContext();\n  const { weights, indirectAttainment } = draftState;\n\n  /**\n   * This is the heart of the direct attainment calculation, wrapped in `useMemo` for performance.\n   * It's a \"smart calculator\" that only re-runs this massive calculation when its dependencies change.\n   */\n  const directAttainment = useMemo(() => {\n    if (!selectedProgram || !selectedBatch) return {};\n\n    const { courses, courseOutcomes, students, enrollments, assessments, marks, coPoMapping, batches, sections } = data;\n\n    // --- Step 1: Filter everything down to the selected program and batch. ---\n    const batch = batches.find(b => b.programId === selectedProgram.id && b.name === selectedBatch);\n    if (!batch) return {}; // Can't calculate without a valid batch.\n    const sectionIdsForBatch = new Set(sections.filter(s => s.batchId === batch.id).map(s => s.id));\n    const relevantCourses = courses.filter(c => c.programId === selectedProgram.id && (c.status === 'Active' || c.status === 'Completed'));\n    \n    // `coAttainmentLevelMap` will be our final result from the first major calculation phase.\n    // It will store the calculated attainment level (0-3) for every single CO.\n    const coAttainmentLevelMap = new Map<string, number>();\n\n    // --- Step 2: Loop through each course to calculate the attainment of its COs. ---\n    relevantCourses.forEach(course => {\n        const cosForCourse = courseOutcomes.filter(co => co.courseId === course.id);\n        \n        // Find all students who are enrolled in this course AND belong to the selected batch.\n        const studentsInCourseAndBatch = students.filter(s => \n            s.status === 'Active' && s.sectionId && sectionIdsForBatch.has(s.sectionId) &&\n            enrollments.some(e => e.studentId === s.id && e.courseId === course.id)\n        );\n        const totalStudents = studentsInCourseAndBatch.length;\n        if (totalStudents === 0 || cosForCourse.length === 0) return; // Skip if no students or COs.\n\n        // --- Step 2a: Create fast lookup maps for this course's data. ---\n        const assessmentsForCourse = assessments.filter(a => enrollments.some(e => e.courseId === course.id && e.sectionId === a.sectionId));\n        \n        // Student marks map: Student ID -> Assessment ID -> Question Name -> Marks\n        const studentMarksMap = new Map<string, Map<string, Map<string, number>>>();\n        marks.forEach(mark => {\n            if (!studentMarksMap.has(mark.studentId)) studentMarksMap.set(mark.studentId, new Map());\n            const assessmentMap = studentMarksMap.get(mark.studentId)!;\n            assessmentMap.set(mark.assessmentId, new Map(mark.scores.map(s => [s.q, s.marks])));\n        });\n            \n        // CO questions map: CO ID -> [List of Questions]\n        const coQuestionMap = new Map<string, { q: string; maxMarks: number; assessmentId: string }[]>();\n        cosForCourse.forEach(co => coQuestionMap.set(co.id, []));\n        assessmentsForCourse.forEach(a => a.questions.forEach(q => q.coIds.forEach(coId => coQuestionMap.get(coId)?.push({ ...q, assessmentId: a.id }))));\n        \n        // --- Step 2b: For each CO in this course, calculate its attainment level. ---\n        cosForCourse.forEach(co => {\n            const questionsForCo = coQuestionMap.get(co.id) || [];\n            if (questionsForCo.length === 0) { coAttainmentLevelMap.set(co.id, 0); return; }\n            \n            let studentsMeetingTarget = 0;\n            // Loop through every student.\n            studentsInCourseAndBatch.forEach(student => {\n                const totalMaxCoMarks = questionsForCo.reduce((sum, q) => sum + q.maxMarks, 0);\n                let totalObtainedCoMarks = 0;\n                \n                // Get the student's marks for all questions related to this CO.\n                const studentAllMarks = studentMarksMap.get(student.id);\n                if (studentAllMarks) {\n                    totalObtainedCoMarks = questionsForCo.reduce((sum, q) => sum + (studentAllMarks.get(q.assessmentId)?.get(q.q) || 0), 0);\n                }\n                \n                // If the student's percentage score for this CO meets the course target, count them.\n                if (totalMaxCoMarks > 0 && (totalObtainedCoMarks / totalMaxCoMarks) * 100 >= course.target) {\n                    studentsMeetingTarget++;\n                }\n            });\n\n            // Calculate the percentage of students who met the target.\n            const percentageMeetingTarget = totalStudents > 0 ? (studentsMeetingTarget / totalStudents) * 100 : 0;\n            \n            // Convert that percentage into a final attainment level (0-3) for this CO.\n            let attainmentLevel = 0;\n            if (percentageMeetingTarget >= course.attainmentLevels.level3) attainmentLevel = 3;\n            else if (percentageMeetingTarget >= course.attainmentLevels.level2) attainmentLevel = 2;\n            else if (percentageMeetingTarget >= course.attainmentLevels.level1) attainmentLevel = 1;\n            \n            // Store the result in our map.\n            coAttainmentLevelMap.set(co.id, attainmentLevel);\n        });\n    });\n\n    // --- Step 3: Loop through each PO and calculate its final Direct Attainment. ---\n    const poAttainments: { [poId: string]: number } = {};\n    programOutcomes.forEach(po => {\n        // Find all the COs that are mapped to this PO.\n        const relevantMappings = coPoMapping.filter(m => m.poId === po.id && coAttainmentLevelMap.has(m.coId));\n        \n        let weightedSum = 0; // Sum of (CO Attainment Level * Mapping Strength)\n        let totalWeight = 0; // Sum of (Mapping Strength)\n\n        relevantMappings.forEach(mapping => {\n            const coLevel = coAttainmentLevelMap.get(mapping.coId);\n            if (coLevel !== undefined) {\n                weightedSum += coLevel * mapping.level;\n                totalWeight += mapping.level;\n            }\n        });\n\n        // The direct attainment is the weighted average.\n        poAttainments[po.id] = totalWeight > 0 ? parseFloat((weightedSum / totalWeight).toFixed(2)) : 0;\n    });\n\n    return poAttainments;\n  }, [selectedProgram, selectedBatch, data, programOutcomes]);\n  \n\n  // This runs when a user types in an \"Indirect\" attainment input field.\n  const handleIndirectChange = (poId: string, value: string) => {\n    // It updates the `draftState` in the parent component.\n    onStateChange({\n        ...draftState,\n        indirectAttainment: {\n            ...indirectAttainment,\n            [poId]: value\n        }\n    });\n  };\n  \n  // This runs when a user changes the \"Weightage\" inputs.\n  const handleWeightChange = (type: 'direct' | 'indirect', value: string) => {\n    const numValue = parseInt(value, 10);\n    if (isNaN(numValue) || numValue < 0 || numValue > 100) {\n        return; \n    }\n\n    if (type === 'direct') {\n        onStateChange({ ...draftState, weights: { direct: numValue, indirect: 100 - numValue } });\n    } else { // type === 'indirect'\n         onStateChange({ ...draftState, weights: { direct: 100 - numValue, indirect: numValue } });\n    }\n  };\n\n  // This calculates the final \"Overall Attainment\" value for a single PO.\n  const calculateOverall = (poId: string) => {\n    const direct = directAttainment[poId] || 0;\n    \n    // If the user hasn't entered an indirect value, we default to 3.\n    const indirectValue = indirectAttainment[poId];\n    const indirect = (indirectValue === undefined || indirectValue.trim() === '') \n      ? 3 \n      : parseFloat(indirectValue);\n\n    if (isNaN(indirect)) {\n        return 'Invalid';\n    }\n\n    // Apply the weights to get the final score.\n    const directWeight = weights.direct / 100;\n    const indirectWeight = weights.indirect / 100;\n    \n    return (direct * directWeight + indirect * indirectWeight).toFixed(2);\n  };\n  \n  return (\n    <div className=\"bg-white p-6 rounded-lg shadow-md\">\n      <h2 className=\"text-2xl font-bold text-gray-800 mb-6\">PO Attainment Dashboard</h2>\n      <div className=\"overflow-x-auto\">\n        <table className=\"min-w-full border-collapse border border-gray-300\">\n          <thead className=\"bg-gray-50\">\n            <tr>\n              <th className=\"border border-gray-300 p-2 text-sm font-medium text-gray-500 uppercase\">Attainment Type</th>\n              <th className=\"border border-gray-300 p-2 text-sm font-medium text-gray-500 uppercase\">Weightage</th>\n              {programOutcomes.map(po => (\n                <th key={po.id} className=\"border border-gray-300 p-2 text-sm font-medium text-gray-500 uppercase\">{po.number}</th>\n              ))}\n            </tr>\n          </thead>\n          <tbody>\n            <tr className=\"bg-white\">\n              <td className=\"border border-gray-300 p-2 font-semibold text-gray-700\">Direct</td>\n              <td className=\"border border-gray-300 p-1\">\n                <div className=\"flex items-center\">\n                    <input type=\"number\" value={weights.direct} onChange={e => handleWeightChange('direct', e.target.value)} className=\"w-24 p-2 bg-white text-gray-900 border border-gray-300 rounded-md text-center focus:ring-indigo-500 focus:border-indigo-500\" />\n                    <span className=\"ml-1 text-gray-700\">%</span>\n                </div>\n              </td>\n              {programOutcomes.map(po => (\n                <td key={po.id} className=\"border border-gray-300 p-2 text-center font-semibold text-green-600\">{directAttainment[po.id] ?? 'N/A'}</td>\n              ))}\n            </tr>\n            <tr className=\"bg-white\">\n              <td className=\"border border-gray-300 p-2 font-semibold text-gray-700\">Indirect</td>\n               <td className=\"border border-gray-300 p-1\">\n                 <div className=\"flex items-center\">\n                    <input type=\"number\" value={weights.indirect} onChange={e => handleWeightChange('indirect', e.target.value)} className=\"w-24 p-2 bg-white text-gray-900 border border-gray-300 rounded-md text-center focus:ring-indigo-500 focus:border-indigo-500\" />\n                    <span className=\"ml-1 text-gray-700\">%</span>\n                </div>\n              </td>\n              {programOutcomes.map(po => (\n                <td key={po.id} className=\"border border-gray-300 p-1\">\n                  <input\n                    type=\"number\"\n                    step=\"0.1\"\n                    className=\"w-24 p-2 bg-white text-gray-900 border border-gray-300 rounded-md text-center focus:ring-indigo-500 focus:border-indigo-500\"\n                    placeholder=\"3\"\n                    value={indirectAttainment[po.id] ?? ''}\n                    onChange={(e) => handleIndirectChange(po.id, e.target.value)}\n                  />\n                </td>\n              ))}\n            </tr>\n            <tr className=\"bg-gray-100 font-bold\">\n              <td className=\"border border-gray-300 p-2 text-gray-800\">Overall Attainment</td>\n              <td className=\"border border-gray-300 p-2 text-center text-gray-800\">100%</td>\n              {programOutcomes.map(po => (\n                <td key={po.id} className=\"border border-gray-300 p-2 text-center text-xl text-yellow-600\">\n                  {calculateOverall(po.id)}\n                </td>\n              ))}\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n};\n\nexport default POAttainmentDashboard;"
  }
  